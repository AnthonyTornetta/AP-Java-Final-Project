
=== CornTrip ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A fun 2D game based on adventure and collecting resources
 */

package com.corntrip.turnbased;

import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;

import org.newdawn.slick.AppGameContainer;
import org.newdawn.slick.BasicGame;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gui.DeathScreenGUI;
import com.corntrip.turnbased.gui.GUI;
import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;
import com.corntrip.turnbased.world.WorldLoader;

public class CornTrip extends BasicGame
{
	/**
	 * Holds everything in the scene
	 */
	private World world;
	
	/**
	 * Shows up when you die
	 */
	private GUI deathScreen;
	
	public CornTrip()
	{
		super("CornTrip"); // Window title
	}
	
	public static void main(String[] args) throws SlickException
	{
		// Creates the window n jazz
        AppGameContainer app = new AppGameContainer(new CornTrip());
        app.setDisplayMode(Reference.WINDOW_WIDTH, Reference.WINDOW_HEIGHT, false);
        app.start();
	}

	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		gfx.clear();
		
		if(world.getPlayer() != null)
			world.render(gc, gfx);
		else if(deathScreen != null)
			deathScreen.render(gc, gfx);
	}
	
	@Override
	public void init(GameContainer gc) throws SlickException
	{
		// Setup the window
		gc.setMaximumLogicUpdateInterval(Reference.MAX_FPS);
		gc.setTargetFrameRate(Reference.MAX_FPS);
		gc.setAlwaysRender(true);
		gc.setShowFPS(Reference.DEBUG);
		gc.setVSync(true);
		
		initializeResources();
		
		try
		{
			world = WorldLoader.generateWorldFromImage(ImageIO.read(new File("res/maps/map.png")));
		}
		catch (IOException e)
		{
			e.printStackTrace();
			throw new IllegalStateException("Failed to create world from image :(");
		}
	}
	
	private void initializeResources()
	{
		Resources.registerSpriteSheet("tiles", "tiles.png", Reference.TILE_DIMENSIONS, Reference.TILE_DIMENSIONS);
		Resources.registerSpriteSheet("bows", "bows.png", Reference.TILE_DIMENSIONS, Reference.TILE_DIMENSIONS);
		Resources.registerSpriteSheet("swords", "swords.png", Reference.TILE_DIMENSIONS, Reference.TILE_DIMENSIONS);
		Resources.registerSpriteSheet("enemy", "enemies.png", Reference.TILE_DIMENSIONS, Reference.TILE_DIMENSIONS);
		
		Resources.registerImage("player", "player.png");
		Resources.registerImage("arrow", "arrow.png");
		Resources.registerImage("wall", "wall.png");
		Resources.registerImage("enemy", "enemy.png");
		Resources.registerImage("tree", "tree.png");
		Resources.registerImage("gold", "gold.png");
		Resources.registerImage("deposit", "resource-deposit.png");
		Resources.registerImage("generator", "resource-generator.png");
		Resources.registerImage("townhall", "townhall.png");
		Resources.registerImage("health", "health.png");
	}

	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		if(world.getPlayer() != null)
			world.update(gc, delta);
		else if(deathScreen == null)
			deathScreen = new GUI(new DeathScreenGUI(world.getScore()));
	}
}

=== Entity ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A GameObject that knows the world it's in and has an update method
 */

package com.corntrip.turnbased.gameobject;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.world.World;

public abstract class Entity extends GameObject
{
	/**
	 * For getting to know your surroundings
	 */
	private World world;
	
	/**
	 * A GameObject that has an update function that runs every game tick
	 * @param startX The starting x of the object
	 * @param startY The starting y of the object
	 * @param w The width of the object
	 * @param h The height of the object
	 * @param world The world the entity is in
	 */
	public Entity(float startX, float startY, float w, float h, World world)
	{
		super(startX, startY, w, h);
		
		this.world = world;
	}
	
	/**
	 * Called every game tick<br>
	 * This should NOT be used for rendering (but I guess you can if u really want)<br>
	 * Put any logic that needs to be called every frame in here
	 * @param gc The GameContainer this is being called from
	 * @param delta The total time passed since the last call
	 * @throws SlickException If something bad were to happen
	 */
	public abstract void update(GameContainer gc, int delta) throws SlickException;
	
	// Getters & Setters //
	
	public World getWorld() { return world; }
	public void setWorld(World w) { this.world = w; }
}

=== GameObject ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 5/31/18
 * This is our own work except the Slick2D library - ACT & TC
 * The most general form of an object in the scene
 */

package com.corntrip.turnbased.gameobject;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.physics.ICollidable;
import com.corntrip.turnbased.rendering.IRenderable;

public abstract class GameObject implements ICollidable, IRenderable, Cloneable
{
	/**
	 * Used to differentiate between objects
	 */
	private long objectId;
	
	/**
	 * Incremented every time a new GameObject is created.
	 * This allows for each object to have a unique id to differentiate it from objects of the same type.
	 */
	private static long masterId = 0;
	
	/**
	 * Position of the object
	 */
	private float x, y;
	
	/**
	 * Dimensions of the object
	 */
	private float width, height;
	
	private float rotation = 0;
	
	/**
	 * The most general form of something in the game scene.<br>
	 * @param startX The x the object will start at
	 * @param startY The y the object will start at
	 * @param w The width of the object
	 * @param h The height of the object
	 */
	public GameObject(float startX, float startY, float w, float h)
	{
		objectId = masterId;
		masterId++;
		
		x = startX;
		y = startY;
		
		width = w;
		height = h;
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public boolean collidingWith(ICollidable other)
	{
		return collidingWith(other.getX(), other.getY(), other.getWidth(), other.getHeight());
	}
	
	@Override
	public boolean collidingWith(float x, float y, float width, float height)
	{
		// Checks a basic box
		if(x + width >= getX() && x <= getX() + getWidth())
		{
			if(y + height >= getY() && y <= getY() + getHeight())
			{
				return true;
			}
		}
		return false;
	}
	
	@Override
	public boolean equals(Object other)
	{
		if(other instanceof GameObject)
		{
			return ((GameObject)other).getObjectId() == getObjectId();
		}
		return false;
	}
	
	// Getters & Setters //
	
	@Override
	public float getWidth() { return width; }
	@Override
	public float getHeight() { return height; }
	@Override
	public float getX() { return x; }
	@Override
	public float getY() { return y; }
	
	public void setX(float x) { this.x = x; }
	public void setY(float y) { this.y = y; }
	public void setWidth(float w) { this.width = w; }
	public void setHeight(float h) { this.height = h; }
	
	public float getRotation()
	{
		return rotation;
	}
	
	public void setRotation(float rotation) { this.rotation = rotation; }
	
	public long getObjectId() { return objectId; }
	
	public float getAnchorPointX() { return getAnchorPointX(0); }
	public float getAnchorPointY() { return getAnchorPointY(0); }
	public float getAnchorPointX(float off) { return getX() + getWidth() / 2 - off; }
	public float getAnchorPointY(float off) { return getY() + getHeight() / 2 - off; }
}

=== Enemy ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * An Enemy that has a given target to chase after and displays its name and healthbar above it
 */

package com.corntrip.turnbased.gameobject.living;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gui.HealthBarGUI;
import com.corntrip.turnbased.gui.TextGUI;
import com.corntrip.turnbased.world.World;

public abstract class Enemy extends LivingEntity
{
	/**
	 * The target to go after
	 */
	private LivingEntity target;
	
	//simply name
	private String name;
	
	//health and it's Gui
	private HealthBarGUI healthBar;
	private TextGUI nameGUI;
	
	/**
	 * The Antagonist of the story
	 * @param startX The starting x of the enemy
	 * @param startY The starting y of the enemy
	 * @param w The width of the player
	 * @param h The height of the player
	 * @param world The world the enemy is in
	 * @param target The target for the enemy (doesn't have to be the player)
	 */
	public Enemy(float startX, float startY, float w, float h, World world, LivingEntity target, String name)
	{
		super(startX, startY, w, h, world, 2);
		
		this.target = target;
		this.name = name;
		
		// x & y don't matter since im updating them afterwards so 0, 0 is fine for temp
		healthBar = new HealthBarGUI(0, 0, w, 6, Color.red, Color.green, getMaxHealth(), getMaxHealth());		
		nameGUI = new TextGUI(0, 0, name, Color.red);
		nameGUI.setCentered(true);
		
		updateGUIPos();
	}
	
	@Override
	/**
	 * Forces them to take damage as passed
	 */
	public void takeDamage(int dmg)
	{
		super.takeDamage(dmg);
		healthBar.setHealth(getHealth());
	}
	
	@Override
	/*
	 * restores some of the HP lost
	 */
	public void heal(int amt)
	{
		super.heal(amt);
		healthBar.setHealth(getHealth());
	}
	
	/**
	 * updates the GUI's x and y to match the movement
	 */
	public void updateGUIPos()
	{
		healthBar.setX(getX());
		healthBar.setY(getY() - 16);
		
		nameGUI.setX(getX() + getWidth() / 2);
		nameGUI.setY(getY() - 20);
	}
	
	/**
	 * 
	 * @param gc: game container
	 * @param gfx: the graphics used
	 * @param offsetX: simply the offset of x
	 * @param offsetY: simply the y offset
	 * @throws SlickException: makes sure it doesn't break, no try/catch
	 */
	public void renderGUI(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		healthBar.render(gc, gfx, offsetX, offsetY);
		nameGUI.render(gc, gfx, offsetX, offsetY);
	}
	
	// Getters & Setters //
	
	public LivingEntity getTarget() { return target; }
	public void setTarget(LivingEntity t) { this.target = t; }

	public String getName() { return name; }
	public void setName(String name)
	{ 
		this.name = name;
		nameGUI.setText(name);
	}

	public HealthBarGUI getHealthBar() { return healthBar; }
	public void setHealthBar(HealthBarGUI healthBar) { this.healthBar = healthBar; }
}

=== LivingEntity ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * An entity that is also living, that has health and a max health and can die
 */

package com.corntrip.turnbased.gameobject.living;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.util.Helper;
import com.corntrip.turnbased.world.World;

public abstract class LivingEntity extends Entity
{
	private int maxHealth;
	private int health;
	
	/**
	 * An Entity but with health and a clone function
	 * @param startX The x position it starts at
	 * @param startY THe y position it starts at
	 * @param w The width of the LivingEntity
	 * @param h The height of the LivingEntity
	 * @param world The world the entity is in
	 */
	public LivingEntity(float startX, float startY, float w, float h, World world, int maxHealth)
	{
		super(startX, startY, w, h, world);
		health = maxHealth;
		this.maxHealth = maxHealth;
	}
	
	/**
	 * Heals the LivingEntity a given amount
	 * @param amt The amount to heal it by
	 */
	public void heal(int amt)
	{
		health = (int) Helper.clamp(amt + getHealth(), 0, getMaxHealth());
	}
	
	/**
	 * Deals damage to the LivingEntity, and if the health <= 0 it dies
	 * @param amt
	 */
	public void takeDamage(int amt)
	{
		health -= amt;
		if(health <= 0)
			die();
	}
	
	/**
=	 * Removes the LivingEntity from the world when it dies
	 */
	public void die()
	{
		getWorld().removeObject(this);
	}
	
	@Override
	public abstract LivingEntity clone();
	
	// Getters & Setters //
	
	public int getMaxHealth() { return maxHealth; }
	public void setMaxHealth(int maxHealth) { this.maxHealth = maxHealth; }
	
	public int getHealth() { return health; }
	public void setHealth(int health) { this.health = health; }
}

=== Player ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * The player is a LivingEntity controlled by the user
 */

package com.corntrip.turnbased.gameobject.living;

import java.util.List;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.Input;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.modifier.equips.Bow;
import com.corntrip.turnbased.gameobject.modifier.equips.Sword;
import com.corntrip.turnbased.gameobject.modifier.equips.SwungWeapon;
import com.corntrip.turnbased.gameobject.modifier.equips.Weapon;
import com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil.Projectile;
import com.corntrip.turnbased.gameobject.nonliving.resources.Resource;
import com.corntrip.turnbased.gameobject.nonliving.resources.ResourceDeposit;
import com.corntrip.turnbased.gameobject.nonliving.townhall.Townhall;
import com.corntrip.turnbased.gui.GUIElement;
import com.corntrip.turnbased.gui.HealthBarGUI;
import com.corntrip.turnbased.gui.ImageGUI;
import com.corntrip.turnbased.gui.TextGUI;
import com.corntrip.turnbased.util.Helper;
import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;

public class Player extends LivingEntity
{
	/**
	 * Used for calculating movement
	 */
	private float velX = 0, velY = 0;
	
	/**
	 * Stores the experience for getting upgrades
	 */
	private int xp = 0;
	
	/**
	 * Holds the resource the player may or may not be carrying
	 */
	private Resource resourceCarrying = null;
	
	/**
	 * A flag to tell if the upgrade GUI should be displayed
	 */
	private boolean displayUpgradeGUI = false;
	
	/**
	 * The texture of the player
	 */
	private Image texture = Resources.getImage("player");
	
	/**
	 * Max velocity the player should move
	 */
	private static final float MAX_MOVE_SPEED = 5.0f;
	
	/**
	 * A healthbar to display
	 */
	private HealthBarGUI healthBar;
	
	// A bunch of GUIs
	private TextGUI nameGUI;
	private TextGUI xpGUI;
	private TextGUI scoreGUI;
	
	private ImageGUI[] upgradeSlots = new ImageGUI[3];
	private Weapon[] weapons = new Weapon[2];
	private int curWeapon = 0;
	
	/**
	 * Controllable Entity by the user
	 * @param startX The x to start the player at
	 * @param startY The y to start the player at
	 * @param w The width of the player
	 * @param h The height of the player
	 * @param world The world the player is in
	 */
	public Player(float startX, float startY, float w, float h, World world)
	{
		super(startX, startY, w, h, world, 20);
		
		healthBar = new HealthBarGUI(getX(), getY() - 8, getWidth(), 6, Color.red, Color.green, getHealth(), getMaxHealth());
		nameGUI = new TextGUI(getX(), getY() - 20, "Joe Shmoe", Color.blue);
		nameGUI.setCentered(true);
		
		setHealth(getHealth());
		healthBar.setHealth(getHealth());
		
		xpGUI = new TextGUI(30, 30, "0", Color.blue);
		scoreGUI = new TextGUI(Reference.WINDOW_WIDTH - 80, 30, "0", Color.blue);
		
		upgradeSlots[0] = new ImageGUI(0, 0, Resources.getSpriteImage("swords", 0, 0));
		upgradeSlots[1] = new ImageGUI(0, 0, Resources.getSpriteImage("bows", 0, 0));
		upgradeSlots[2] = new ImageGUI(0, 0, Resources.getImage("health"));
		
		weapons[1] = new Bow(this, 1);
		weapons[0] = new Sword(getX() + getWidth(), getY(), 32, 32, this, 1);
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		getHeldWeapon().update(delta);
		
		float subVal = 0.8f;
		float moveBy = Reference.MAX_FPS * delta / 1000.0f;
		
		velX -= Math.signum(velX) * subVal * moveBy;
		velY -= Math.signum(velY) * subVal * moveBy;
		
		// If the velocities are somewhere near 0, just set them to 0 so it doesn't slide forever
		if(velX <= subVal && velX >= -subVal)
			velX = 0;
		if(velY <= subVal && velY >= -subVal)
			velY = 0;
		
		// Fun movement calcs in here
		
		Input in = gc.getInput();
		if(in.isKeyDown(Input.KEY_W) || in.isKeyDown(Input.KEY_UP))
			velY += -2.0f * moveBy;
		if(in.isKeyDown(Input.KEY_S) || in.isKeyDown(Input.KEY_DOWN))
			velY += 2.0f * moveBy;
		
		if(in.isKeyDown(Input.KEY_A) || in.isKeyDown(Input.KEY_LEFT))
			velX += -2.0f * moveBy;
		if(in.isKeyDown(Input.KEY_D) || in.isKeyDown(Input.KEY_RIGHT))
			velX += 2.0f * moveBy;
		
		// End movement calcs
		
		if(in.isMouseButtonDown(Input.MOUSE_LEFT_BUTTON))
		{
			getHeldWeapon().attack();
		}
		
		if(displayUpgradeGUI)
		{
			if(in.isKeyDown(Input.KEY_Z))
			{
				if(!weapons[0].isMaxTier())
				{
					if(xp - 7 >= 0)
					{
						weapons[0] = weapons[0].upgrade();
						xp -= 7;
					}
				}
			}
			else if(in.isKeyDown(Input.KEY_X))
			{
				if(!weapons[1].isMaxTier())
				{
					if(xp - 10 >= 0)
					{
						weapons[1] = weapons[1].upgrade();
						xp -= 10;
					}
				}
			}
			else if(in.isKeyDown(Input.KEY_C))
			{
				if(xp - 2 >= 0)
				{
					heal(getMaxHealth());
					xp -= 2;
				}
			}
		}
		
		if(in.isKeyDown(Input.KEY_1))
			curWeapon = 0;
		else if(in.isKeyDown(Input.KEY_2))
			curWeapon = 1;
		
		if(resourceCarrying == null)
		{
			velX = Helper.clamp(velX, -MAX_MOVE_SPEED, MAX_MOVE_SPEED);
			velY = Helper.clamp(velY, -MAX_MOVE_SPEED, MAX_MOVE_SPEED);
		}
		else
		{
			velX = Helper.clamp(velX, -MAX_MOVE_SPEED / 3, MAX_MOVE_SPEED / 3);
			velY = Helper.clamp(velY, -MAX_MOVE_SPEED / 3, MAX_MOVE_SPEED / 3);
		}
		
		float newX = velX + getX();
		float newY = velY + getY();
		
		List<GameObject> objs = getWorld().getGameObjects();
		for(int i = 0; i < objs.size(); i++)
		{
			if(!objs.get(i).equals(this))
			{
				GameObject go = objs.get(i);
				
				if(go instanceof Townhall)
				{
					Townhall th = (Townhall)go;
					if(th.withinRange(this))
						displayUpgradeGUI = true;
					else
						displayUpgradeGUI = false;
				}
				
				if(go.collidingWith(newX, newY, getWidth(), getHeight()))
				{
					if(go instanceof ResourceDeposit)
					{
						if(resourceCarrying != null)
						{
							scoreResource(resourceCarrying);
							resourceCarrying = null;
						}
					}
					else if(go instanceof Resource)
					{
						if(resourceCarrying == null)
						{
							resourceCarrying = (Resource) go;
							getWorld().removeObject(go);
						}
					}
					else if(!(go instanceof Enemy))
					{
						if(go.collidingWith(newX, newY, getWidth(), getHeight()))
						{
							if(go instanceof Projectile)
							{
								Projectile proj = (Projectile)go;
								if(proj.getWeapon().getOwner().equals(this))
								{
									continue;
								}
							}
							
							float oldX = getX();
							float oldY = getY();
							
							final float FACTOR = 0.001f; // the lower this is the more precise but the more iterations - this is a decent value
							
							float difX = newX - oldX;
							float difY = newY - oldY;
							
							while(go.collidingWith(getX() + difX, getY(), getWidth(), getHeight()))
								difX -= Math.signum(velX) * FACTOR;
							while(go.collidingWith(getX(), getY() + difY, getWidth(), getHeight()))
								difY -= Math.signum(velY) * FACTOR;								
							
							newX = getX() + difX;
							newY = getY() + difY;
						}
					}
				}
			}
		}
		
		if(newX != getX() + velX) // If the newX is not equal to the original calculation, the object collided into something causing it to change
			velX = 0; // Since you just rammed into something, I don't think your going in that direction any more
		if(newY != getY() + velY)
			velY = 0;
		
		setX(newX);
		setY(newY);
		
		setX(Helper.clamp(getX(), 0, getWorld().getWidth() - getWidth()));
		setY(Helper.clamp(getY(), 0, getWorld().getHeight() - getHeight()));
		
		if(getHeldWeapon() instanceof SwungWeapon)
		{
			SwungWeapon sw = (SwungWeapon)getHeldWeapon();
			
			sw.setX(getX() + -2 * (Math.abs(getRotation()) / 90) + 2 * getWidth());
			sw.setY(getY() + ((getRotation() % 45) / 45.0f) * getHeight());
		}
		
		healthBar.setX(getX());
		healthBar.setY(getY() - 16);
		healthBar.setHealth(getHealth());
		
		nameGUI.setX(getX() + getWidth() / 2);
		nameGUI.setY(getY() - 46);
		
		upgradeSlots[0].setX(getX() - 48);
		upgradeSlots[0].setY(getY() - 128);
		upgradeSlots[1].setX(getX());
		upgradeSlots[1].setY(getY() - 128);
		upgradeSlots[2].setX(getX() + 48);
		upgradeSlots[2].setY(getY() - 128);
		
		if(getWorld().getTownhall().withinRange(this))
		{
			displayUpgradeGUI = true;
		}
		
		xpGUI.setText(getXp() + "xp");
		scoreGUI.setText(getWorld().getScore() + " score");
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{		
		gfx.setColor(Color.green);
		
		// For rotation
		Input input = gc.getInput();
		int mouseX = input.getMouseX();
		int mouseY = input.getMouseY();
		
		float anchorX = getAnchorPointX(offsetX);
		float anchorY = getAnchorPointY(offsetY);
		
		healthBar.render(gc, gfx, offsetX, offsetY);
		nameGUI.render(gc, gfx, offsetX, offsetY);
		
		xpGUI.render(gc, gfx);
		scoreGUI.render(gc, gfx);
		
		if(displayUpgradeGUI)
		{
			for(GUIElement elem : upgradeSlots)
			{
				elem.render(gc, gfx, offsetX, offsetY);
			}
		}
		
		setRotation(Helper.getAngle(anchorX, anchorY, mouseX, mouseY));
		
		gfx.setColor(Color.green);
		if(Reference.DEBUG)
			gfx.drawLine(anchorX, anchorY, input.getMouseX(), input.getMouseY());
		
		gfx.rotate(anchorX, anchorY, getRotation());
		
		float drawX = getX() - offsetX;
		float drawY = getY() - offsetY;
		texture.draw(drawX, drawY);
		
		getHeldWeapon().renderAt(gc, gfx, drawX + getWidth(), drawY);
	}
	
	private void scoreResource(Resource r)
	{
		if(r != null)
		{
			getWorld().addToScore(r.getPtsValue());
			getWorld().initateNextWave();
		}
	}
	
	@Override
	public LivingEntity clone()
	{
		return new Player(getX(), getY(), getWidth(), getHeight(), getWorld());
	}
	
	public Weapon getHeldWeapon() { return weapons[curWeapon]; }
	
	public int getXp() { return xp; }
	public void addXp(int amt) { xp += amt; }
}

=== TestEnemy ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A test enemy that moves to you in a "creative" way
 */

package com.corntrip.turnbased.gameobject.living;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.util.Helper;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;

public class TestEnemy extends Enemy
{
	private Image img;
	private int tier;
	
	public TestEnemy(float startX, float startY, float w, float h, World world, LivingEntity target, String name, int tier)
	{
		super(startX, startY, w, h, world, target, name);
		this.tier = Helper.clamp(tier, 0, getMaxTier());
		//implements the spritesheet stuffs
		img = Resources.getSpriteImage("enemy", tier - 1, 0);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		renderGUI(gc, gfx, offsetX, offsetY);
		
		gfx.setColor(Color.red);
		gfx.rotate(getAnchorPointX(offsetX), getAnchorPointY(offsetY), getRotation());
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		LivingEntity target = getTarget();
		
		if(target != null) // the target has been set
		{
			float targetX = target.getX();
			float targetY = target.getY();
			
			float xd = Helper.clamp(targetX - getX(), -1, 1);
			float xdy = Helper.clamp(targetY - getY(), -1, 1);
			
			float moveX = (float)Math.random() * 10 - 5 + xd;
			float moveY = (float)Math.random() * 10 - 5 + xdy;
			
			setX(getX() + moveX);
			setY(getY() + moveY);
			
			setRotation(Helper.getAngle(getAnchorPointX(), getAnchorPointY(), target.getAnchorPointX(), target.getAnchorPointY()));
			
			if(this.collidingWith(target))
			{
				getWorld().removeObject(this);
				target.takeDamage(tier);
			}
		}
		
		updateGUIPos();
	}
	
	@Override
	public LivingEntity clone()
	{
		return new TestEnemy(getX(), getY(), getWidth(), getHeight(), getWorld(), getTarget(), getName(), tier);
	}
	
	public int getMaxTier() { return 5; }
}

=== Equipable ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Something that can be held
 */

package com.corntrip.turnbased.gameobject.modifier;

import org.newdawn.slick.Image;

public abstract class Equipable
{	
	//lol gets the image
	public abstract Image getImage();
}
//tacking on swords and stuff

=== Modified ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * ?
 */

package com.corntrip.turnbased.gameobject.modifier;

import com.corntrip.turnbased.gameobject.living.LivingEntity;

public abstract class Modified
{
	LivingEntity assigned = null;
	
	//get and sets to what it's assigned
	public  void setAssinged(LivingEntity a)
	{
		assigned = a;
	}
	public LivingEntity getAssigned()
	{
		return assigned;
	}
	
	//changes stats to correspond with the name
	public abstract void modifyStats(LivingEntity a);
	
	//changes name
	public abstract String modifiedName(String n);
}

=== HPMod ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * During unit spawn there should be a ArrayList of these bad boys and it should have a random chance to spawn a boss
 * Which then links it to a new Creation of one of these
 */

package com.corntrip.turnbased.gameobject.modifier.entityAddition;

import java.util.ArrayList;

import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.modifier.Modified;

/**
 * During unit spawn there should be a ArrayList of these bad boys and it should have a random chance to spawn a boss
 * Which then links it to a new Creation of one of these
 */
public class HPMod extends Modified
{

	private ArrayList<String> modNames;
	
	HPMod()
	{
		modNames = new ArrayList<String>();
		modNames.add("Giant");
		modNames.add("Huge");
		modNames.add("Gigantic");
		modNames.add("Large");
		modNames.add("Big");
	}
	
	public void modifyStats(LivingEntity a)
	{
		a.setHealth(a.getHealth() + 10);
	}

	/* 
	 * n: simply the name before
	 * a: list of possible modifiers
	 */
	public String modifiedName(String n) 
	{
		return modNames.get((int)(Math.random()*modNames.size())) + " " + n;
	}

}

=== Bow ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Shoots an arrow when fired
 */

package com.corntrip.turnbased.gameobject.modifier.equips;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil.Arrow;
import com.corntrip.turnbased.util.Resources;

public class Bow extends Weapon
{
	private int timeSinceLastShot = 0;
	private int waitTimesBetweenShots = 2000;
	
	/**
	 * 
	 * @param owner: who the weapon belongs to
	 * @param tier: what stage the weapon is in (how strong)
	 */
	public Bow(Entity owner, int tier)
	{
		setOwner(owner);
		setTier(tier);
		waitTimesBetweenShots = timeSinceLastShot = 2000 / tier;
		setDamage((float)(tier*4.212));
		setImage(Resources.getSpriteImage("bows", tier - 1, 0));
	}
	
	@Override
	/**
	 * checks to make sure you're within attack time then creates a new arrow at the bow's centre
	 */
	public void attack() 
	{
		if(timeSinceLastShot < waitTimesBetweenShots)
			return;
		timeSinceLastShot = 0;
		
		getOwner().getWorld().addObject(new Arrow(getOwner().getX() + getOwner().getWidth() / 2,
							getOwner().getY() + getOwner().getHeight() / 2, 
							15.0f, 10.0f, 
							getOwner().getWorld(), this, Resources.getImage("arrow")));
	}
	
	@Override
	/**
	 * delta is the game timer, increases as the game goes
	 */
	public void update(int delta)
	{
		timeSinceLastShot += delta;
	}
	
	@Override
	/**
	 * creates the new bow in the old one's place and upgrades it
	 */
	public Bow upgrade() 
	{
		return new Bow(getOwner(), getTier() + 1);
	}
	
	@Override
	/*
	 * makes sure the the tier is not higher than the max
	 */
	public boolean isMaxTier() { return getTier() >= 5; }
}

=== Sword ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Hits in a box around it's width, height, x, and y.
 */

package com.corntrip.turnbased.gameobject.modifier.equips;

import java.util.List;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.living.Player;
import com.corntrip.turnbased.util.Resources;

public class Sword extends SwungWeapon
{
	/**
	 * 
	 * @param x: x start
	 * @param y: y start
	 * @param w: width
	 * @param h: height
	 * @param owner: the entity who controls it
	 * @param tier: how upgraded the sword is
	 */
	public Sword(float x, float y, float w, float h, Entity owner, int tier)
	{
		super(x, y, w, h, 500 / tier);
		setTier(tier);
		setDamage((float) (tier*6.862));
		setOwner(owner);
		setImage(Resources.getSpriteImage("swords", tier - 1, 0));
	}
	
	@Override
	/**
	 * swings the sword and brings a hitbox to the game
	 * also adds the damage and kills items
	 */
	public void attack()
	{
		if(getTimeSinceLastSwing() < getWaitTimesBetweenSwings())
			return;
		setTimeSinceLastSwing(0);
		
		List<GameObject> thingsHit = generateHitbox(getX(), getY(), getWidth(), getHeight());
		
		for(GameObject hitEnemy : thingsHit)
		{
			if(hitEnemy instanceof LivingEntity)
			{
				((LivingEntity) hitEnemy).takeDamage((int)(getDamage()+0.5));;
				
				if(getOwner() instanceof Player)
				{
					Player p = (Player)getOwner();
					p.addXp(1);
				}
			}
		}
		
		setRotation(90);
	}
	
	@Override
	/**
	 * upgrades the sword like the bow
	 */
	public Sword upgrade() 
	{		
		return new Sword(getX(), getY(), getWidth(), getHeight(), getOwner(), getTier() + 1);
	}
	
	@Override
	/**
	 * max tier as seen before
	 */
	public boolean isMaxTier() { return getTier() >= 4; }
}

=== SwungWeapon ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A weapon that is swang'd instead of shot
 */

package com.corntrip.turnbased.gameobject.modifier.equips;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;

public abstract class SwungWeapon extends Weapon
{
	//getting the place of the item and it's rotation
	private float x, y, width, height;
	private float rotation;
	//these two are dedicated to creating a limiter on swings
	private int timeSinceLastSwing;
	private int waitTimesBetweenSwings;
	
	/**
	 * 
	 * @param x: where the item's x will start
	 * @param y: where the item's y will start
	 * @param w: how wide the object will be
	 * @param h: how tall the object will be
	 * @param waitTime: time between swings in milliseconds
	 */
	public SwungWeapon(float x, float y, float w, float h, int waitTime)
	{
		this.x = x;
		this.y = y;
		this.width = w;
		this.height = h;
		this.waitTimesBetweenSwings = timeSinceLastSwing = waitTime;
		rotation = 0;
	}
	
	/**
	 * resets the swing to it's normal position
	 */
	@Override
	public void update(int delta)
	{
		if(rotation > 0)
			rotation -= 5;
		else
			rotation = 0;
		
		timeSinceLastSwing += delta;
	}
	
	/**
	 * shows the actual image and it's movement when needed
	 */
	@Override
	public void renderAt(GameContainer gc, Graphics gfx, float x, float y)
	{
		gfx.rotate(x + getImage().getWidth() / 2, y + getImage().getHeight(), rotation);
		
		super.renderAt(gc, gfx, x, y);
	}
	
	//tons of getters and setters
	public float getX() { return x; }
	public float getY() { return y; }
	public float getWidth() { return width; }
	public float getHeight() { return height; }

	public void setX(float x) { this.x = x; }
	public void setY(float y) { this.y = y; }
	public void setWidth(float width) { this.width = width; }
	public void setHeight(float height) { this.height = height; }

	public float getRotation() { return rotation; }
	public void setRotation(float rotation) { this.rotation = rotation; }

	public int getTimeSinceLastSwing() { return timeSinceLastSwing; }
	public void setTimeSinceLastSwing(int t) { this.timeSinceLastSwing = t; }

	public int getWaitTimesBetweenSwings() { return waitTimesBetweenSwings; }
	public void setWaitTimesBetweenSwings(int w) { this.waitTimesBetweenSwings = w; }
}

=== Weapon ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A weapon that has an attack function
 * Whenever an enemy is hit, if the owner is a player it's xp goes up
 */

package com.corntrip.turnbased.gameobject.modifier.equips;

import java.util.ArrayList;
import java.util.List;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.modifier.Equipable;

public abstract class Weapon extends Equipable
{
	//simply the stuffers
	private Entity owner;
	private float damage;
	private Image image;
	private int tier;
	
	//Start x and y are the owner's hit box
	public List<GameObject> generateHitbox(float startX, float startY, float width, float height)
	{
		List<GameObject> itemsHit = new ArrayList<>();
		
		for(GameObject a: owner.getWorld().getGameObjects())
		{
			//hahah no longer hits owner
			
			if(a instanceof LivingEntity)
			{
				if((!owner.equals(a) && ((LivingEntity)a).collidingWith(startX, startY, width, height)))
				{
					itemsHit.add((Entity) a);
				}
			}
		}
		return itemsHit;
	}
	
	//draws the items
	public void renderAt(GameContainer gc, Graphics gfx, float x, float y)
	{
		getImage().draw(x, y);
	}
	
	//defined in depth later
	public abstract void attack();
	
	public abstract Weapon upgrade();
	public abstract void update(int delta);
	
	// Getters & Setters //
	
	public void setTier(int t) { tier = t; }
	public int getTier() { return tier; }
	public float getDamage() { return damage; }
	public Entity getOwner() { return owner; }
	public Image getImage() { return image; }
	public void setImage(Image image) { this.image = image; }
	public void setOwner(Entity owner) { this.owner = owner; }
	public void setDamage(float damage) { this.damage = damage; }

	public abstract boolean isMaxTier();
}

=== Arrow ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A projectile that is an arrow
 */

package com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.modifier.equips.Weapon;
import com.corntrip.turnbased.world.World;

public class Arrow extends Projectile
{
	//building of an arrow based off the projectile
	public Arrow(float startX, float startY, float w, float h, World world, Weapon wep, Image image)
	{
		super(startX, startY, w, h, world, wep, wep.getOwner().getRotation(), image);	
	}

	/**
	 * individual flight speed
	 */
	@Override
	public float flightSpeed() 
	{
		return 25.0f;
	}

	//actually adding the arrow to the game
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		//rotating so it adds correctly and then drawing it
		gfx.rotate((getX() - offsetX) + getWidth() / 2, (getY() - offsetY) + getHeight() / 2, getRotation());
		getImage().draw(getX() - offsetX, getY() - offsetY);
	}
}

=== Projectile ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Travels in a given direction based off the shooter's rotation with slight variation
 */

package com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil;

import java.util.List;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.living.Player;
import com.corntrip.turnbased.gameobject.modifier.equips.Weapon;
import com.corntrip.turnbased.world.World;

public abstract class Projectile extends Entity
{
	//host item that uses the projectile
	private Weapon wep;
	//velocities, used to calc next x and/or y and rotation
	private float velX, velY;
	//total distance traveled
	private float distanceTrav;
	private Image image;
	
	private static final float INNACURACY = 25f; // more = less :P
	
	/**
	 * 
	 * @param startX: starting coord for Entity
	 * @param startY: same as x but y
	 * @param w: width
	 * @param h: height
	 * @param world: world the Entity is in
	 * @param wep: owner of the projecile (host)
	 * @param rotation: where the player is pointing in radians
	 */
	public Projectile(float startX, float startY, float w, float h, World world, Weapon wep, float rotation, Image image)
	{
		super(startX, startY, w, h, world);
		setRotation(rotation);
		this.image = image;
		this.wep = wep;
		distanceTrav = 0;
		
		setProjectileDirection();
	}
	
	/**
	 * how fast the projectile is going
	 * @return Better freaking be < 32
	 */
	public abstract float flightSpeed();
	
	/**
	 * sets how far the arrow will go
	 * @return sets how far the arrow will go
	 */
	public float flightMax()
	{
		return wep.getTier() * 600 * flightSpeed();
	}
	
	/**
	 * removes the projectile from the world
	 */
	public void endPath()
	{
		getWorld().removeObject(this);
	}
	
	/**
	 * uses super maths to set where the x,y will be aiming
	 */
	public void setProjectileDirection()
	{
		/*
		 * == TODO ==
		 * This calculation causes the arrow to move in a diamond-like pattern, causing inaccuracies when moving towards the target.
		 * This effect is strongest at angles +-45 and +-135
		 * This effect is weakest at angles +- 0 and +- 180
		 */
		if(getRotation() >= 0 && getRotation() < 90)
		{
			velY = getRotation() / 90;
			velX = 1 - velY;
		}
		else if(getRotation() >= 90 && getRotation() <= 180)
		{
			velY = Math.abs(getRotation() / 90 - 2);
			velX = -1 + velY;
		}
		else if(getRotation() > -180 && getRotation() < -90)
		{
			velY = ((getRotation() + 180) / -90);
			velX = -1 - velY;
		}
		else
		{
			velY = getRotation() / 90;
			velX = 1 + velY;
		}
		
		velY += (Math.random() / INNACURACY - 0.5 / INNACURACY);
		velX += (Math.random() / INNACURACY - 0.5 / INNACURACY);
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		//once it reaches it's distance it's removed from the world
		//the issue with this is that the diagonals will be shorter than the verticals, I think
		if(distanceTrav >= flightMax())
		{
			endPath();
		}
		
		//setting the new x,y coordinates according to the algorithm
		setX(getX() + velX * flightSpeed());
		setY(getY() + velY * flightSpeed());
		
		//checks the enemies hit
		List<GameObject> thingsHit = wep.generateHitbox(super.getX(), super.getY(), super.getWidth(), super.getHeight());
		
		//hits the first enemy and destroys the projectile
		if(thingsHit.size() > 0)
		{
			for(GameObject go : thingsHit)
			{
				if(!(go instanceof LivingEntity))
				{
					endPath();
					return;
				}
			}
			
			((LivingEntity)thingsHit.get(0)).takeDamage((int)(wep.getDamage()+0.5));
			
			if(getWeapon().getOwner() instanceof Player)
			{
				Player p = (Player)getWeapon().getOwner();
				p.addXp(1);
			}
			
			endPath();
		}
		
		//increases the current distance traveled
		distanceTrav += flightSpeed();
	}

	//get and sets
	public Image getImage() { return image; }

	public void setImage(Image image) { this.image = image;}

	public Weapon getWeapon() { return wep; }
}

=== Tree ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A simple tree that sits there and is a tree
 */

package com.corntrip.turnbased.gameobject.nonliving;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Resources;

public class Tree extends GameObject
{
	private Image texture;
	
	/**
	 * Sits there and acts like a wall.
	 * @param startX The x to sit at
	 * @param startY The y to sit at
	 * @param w The width of the wall
	 * @param h The height of the wall
	 */
	public Tree(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		texture = Resources.getImage("tree");
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float xOffset, float yOffset)
	{
		texture.draw(getX() - xOffset, getY() - yOffset);
	}
}

=== Wall ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A simple wall that sits there and is a wall
 */

package com.corntrip.turnbased.gameobject.nonliving;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.GameObject;

public class Wall extends GameObject
{
	private Image texture;
	
	/**
	 * Sits there and acts like a wall.
	 * @param startX The x to sit at
	 * @param startY The y to sit at
	 * @param w The width of the wall
	 * @param h The height of the wall
	 */
	public Wall(float startX, float startY, float w, float h, Image texture)
	{
		super(startX, startY, w, h);
		this.texture = texture;
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float xOffset, float yOffset)
	{
		texture.draw(getX() - xOffset, getY() - yOffset);
	}
}

=== GoldResource ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A resource that looks like gold
 */

package com.corntrip.turnbased.gameobject.nonliving.resources;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.util.Resources;

public class GoldResource extends Resource
{
	private Image img;
	
	/**
	 * Builds a new gold resource
	 * @param startX: starting x
	 * @param startY: starting y
	 * @param w: width
	 * @param h: height
	 */
	public GoldResource(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		img = Resources.getImage("gold");
	}
	
	@Override
	/**
	 * returns how many points the player has earned
	 */
	public int getPtsValue()
	{
		return 1;
	}
	
	@Override
	/**
	 * actually places the image into the game
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY)
	{
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	@Override
	/**
	 * adds another gold resource if it was destroyed
	 */
	public Resource createNew()
	{
		return new GoldResource(getX(), getY(), getWidth(), getHeight());
	}
}

=== Resource ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Something that is collectible by the player and can be used to gain points
 */

package com.corntrip.turnbased.gameobject.nonliving.resources;

import com.corntrip.turnbased.gameobject.GameObject;

public abstract class Resource extends GameObject
{
	/**
	 * 
	 * @param startX: starting x
	 * @param startY: starting y
	 * @param w: width
	 * @param h: hieght
	 */
	public Resource(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
	}
	
	// Getters & Setters //
	
	public abstract int getPtsValue();
	public abstract Resource createNew();
}

=== ResourceDeposit ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A place where the player can deposit his/her resource
 */

package com.corntrip.turnbased.gameobject.nonliving.resources;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Resources;

public class ResourceDeposit extends GameObject
{
	private Image img;
	
	/**
	 * Builds a new resource deposit
	 * @param startX: starting x
	 * @param startY: starting y
	 * @param w: width
	 * @param h: hieght
	 */
	public ResourceDeposit(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		img = Resources.getImage("deposit");
	}

	@Override
	/**
	 * shows the deposit in the game
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{		
		img.draw(getX() - offsetX, getY() - offsetY);
	}
}

=== ResourceGenerator ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Creates a resources in the scene every time the time ellapsed is greator than the spawn delay
 */

package com.corntrip.turnbased.gameobject.nonliving.resources;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;

public class ResourceGenerator extends Entity
{
	private int timeSinceLastSpawn = 0;
	private int spawnDelayMS;
	private Resource resource;
	private Resource resourceLaidDown = null;
	
	private Image img;
	
	/**
	 * 
	 * @param startX: starting x
	 * @param startY: starting y
	 * @param w: width
	 * @param h: hieght
	 * @param world: world that the generator exists in
	 * @param spawnDelayMS: delay in miliseconds
	 * @param resource: the items that it's spawning
	 */
	public ResourceGenerator(float startX, float startY, float w, float h, World world, int spawnDelayMS, Resource resource)
	{
		super(startX, startY, w, h, world);
		this.spawnDelayMS = spawnDelayMS;
		this.resource = resource;
		
		img = Resources.getImage("generator");
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	/**
	 * brings the object into the game
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY)
	{
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		//checks to see if it has a resource yet
		if(resourceLaidDown != null)
		{
			if(!getWorld().containsObject(resourceLaidDown))
			{
				resourceLaidDown = null;
			}
		}
		
		//resets the timer
		if(resourceLaidDown == null)
			timeSinceLastSpawn += delta; // Only spawn if no resource is present
		else
			timeSinceLastSpawn = 0;
		
		//throws a delay so there aren't too many resources
		if(timeSinceLastSpawn >= spawnDelayMS)
		{
			resourceLaidDown = resource.createNew();
			timeSinceLastSpawn = 0;
			
			boolean colliding = false;
			
			//places a resource into the world while keeping it out of the generator (randomly)
			do
			{
				colliding = false;
				resourceLaidDown.setX((int)(getX() + (Math.random() * 200) - 50));
				resourceLaidDown.setY((int)(getY() + (Math.random() * 200) - 50));
				
				for(GameObject go : getWorld().getGameObjects())
				{
					if(go.collidingWith(resourceLaidDown))
					{
						colliding = true;
						break;
					}
				}
				
				//creates a new one when colliding
			} while(colliding);
			
			getWorld().addObject(resourceLaidDown);
		}
	}
}

=== Townhall ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Acts as the upgrading center for the player
 */

package com.corntrip.turnbased.gameobject.nonliving.townhall;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Resources;

public class Townhall extends GameObject
{
	private Image img;
	
	/**
	 * Builds a new townhall into the world
	 * @param startX: starting x
	 * @param startY: starting y
	 * @param w: width
	 * @param h: hieght
	 */
	public Townhall(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		img = Resources.getImage("townhall");
	}

	@Override
	/**
	 * shows the townhall
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	/**
	 * 
	 * @param go: game object
	 * @return True/False if the object is in range
	 */
	public boolean withinRange(GameObject go)
	{
		float thisAnchorX = getX() + getWidth() / 2;
		float thisAnchorY = getY() + getHeight() / 2;
		
		float theirAnchorX = go.getX() + go.getWidth() / 2;
		float theirAnchorY = go.getY() - go.getHeight() / 2;
		
		//calculation to see if they're in range
		double distanceAway = Math.sqrt(Math.pow(theirAnchorX - thisAnchorX, 2) + Math.pow(theirAnchorY - thisAnchorY, 2));
		
		return distanceAway < (getWidth() + getHeight());
	}
}

=== DeathScreenGUI ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Displays a black screen w/ score and "You Died!"
 */

package com.corntrip.turnbased.gui;

import java.awt.Font;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.TrueTypeFont;

import com.corntrip.turnbased.util.Reference;

public class DeathScreenGUI extends GUIElement
{
	private TextGUI scoreGUI; // Says your score
	private TextGUI youDied; // Says "You Died!"
	
	/**
	 * Displays a black screen w/ score and "You Died!"
	 * @param score the score to display
	 */
	public DeathScreenGUI(int score)
	{
		super(0, 0);
		
		// Displays the score
		scoreGUI = new TextGUI(Reference.WINDOW_WIDTH / 2, Reference.WINDOW_HEIGHT / 2 - 50, "Score: " + score, Color.green);
		scoreGUI.setCentered(true);
		scoreGUI.setFont(new TrueTypeFont(new Font("Verdana", Font.BOLD, 45), true));
		
		// Displays "You Died!"
		youDied = new TextGUI(Reference.WINDOW_WIDTH / 2, Reference.WINDOW_HEIGHT / 2 - 120, "You Died!", Color.green);
		youDied.setCentered(true);
		youDied.setFont(new TrueTypeFont(new Font("Verdana", Font.BOLD, 45), true));
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		gfx.setColor(Color.black);
		gfx.fillRect(0, 0, Reference.WINDOW_WIDTH, Reference.WINDOW_HEIGHT);
		scoreGUI.render(gc, gfx, offsetX, offsetY);
		youDied.render(gc, gfx, offsetX, offsetY);
	}
}

=== GUI ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Displays a GUI with elements in it
 */

package com.corntrip.turnbased.gui;

import java.util.ArrayList;
import java.util.List;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.rendering.IRenderable;

public class GUI implements IRenderable
{
	/**
	 * Each element present in the array
	 */
	private List<GUIElement> elements = new ArrayList<>();
	
	/**
	 * Is a GUI holder and renders each
	 * @param e All the elements to initialize the GUI with
	 */
	public GUI(GUIElement... e)
	{
		for(GUIElement elem : e)
		{
			elements.add(elem);
		}
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		for(GUIElement elem : elements)
		{
			elem.render(gc, gfx, offsetX, offsetY);
		}
	}

	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
}

=== GUIBar ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A GUI that is treated as a bar
 */

package com.corntrip.turnbased.gui;

public abstract class GUIBar extends GUIElement
{
	private float width, height;
	/**
	 * Generates a bar as a GUI
	 * @param x Starting x
	 * @param y Starting y
	 * @param w Width of the bar
	 * @param h Height of the bar
	 */
	public GUIBar(float x, float y, float w, float h)
	{
		super(x, y);
		width = w;
		height = h;
	}
	
	// Getters & Setters //
	
	public float getWidth() { return width; }
	public void setWidth(float width) { this.width = width; }
	
	public float getHeight() { return height; }
	public void setHeight(float height) { this.height = height; }
}

=== GUIElement ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Something that is renderable in the scene as a GUI element
 */

package com.corntrip.turnbased.gui;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.rendering.IRenderable;

public abstract class GUIElement implements IRenderable
{
	private float x, y;
	
	/**
	 * Assigning the starting spot
	 * @param x; start x
	 * @param y; start y
	 */
	public GUIElement(float x, float y)
	{
		this.x = x;
		this.y = y;
	}
	
	@Override
	/**
	 * rendering with offesets
	 */
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	/**
	 * rendering that'll be done with other GUI items
	 */
	public abstract void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException;
	
	//public abstract void handleKey(int key); <-- TODO: Put me somewhere else

	public float getX() { return x; }
	public void setX(float x) { this.x = x; }

	public float getY() { return y; }
	public void setY(float y) { this.y = y; }
}

=== HealthBarGUI ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Displays a healthbar in the scene based off the amount of health and the max health
 */

package com.corntrip.turnbased.gui;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

public class HealthBarGUI extends GUIBar
{
	private Color healthBackground, healthColor;
	private int health, maxHealth;
	
	/**
	 * 
	 * @param x: start x
	 * @param y: start y
	 * @param w: width
	 * @param h: height
	 * @param healthBackground: what shows when hp is lost
	 * @param healthColor: what hp looks like
	 * @param health: numerical representation of health
	 * @param maxHealth: maximum health
	 */
	public HealthBarGUI(float x, float y, float w, float h, Color healthBackground, Color healthColor, int health, int maxHealth)
	{		
		super(x, y, w, h);
		this.healthBackground = healthBackground;
		this.healthColor = healthColor;
		this.health = health;
		this.maxHealth = maxHealth;
	}

	/**
	 * Sets the health bar above the entity's head when called
	 */
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		gfx.setColor(healthBackground);
		gfx.fillRect(getX() - offsetX, getY() - offsetY, getWidth(), getHeight());
		
		gfx.setColor(healthColor);
		gfx.fillRect(getX() - offsetX, getY() - offsetY, health / (float)maxHealth * getWidth(), getHeight());
	}
	
	// Getters & Setters //
	
	public Color getHealthBackground() { return healthBackground; }
	public void setHealthBackground(Color healthBackground) { this.healthBackground = healthBackground; }

	public Color getHealthColor() { return healthColor; }
	public void setHealthColor(Color healthColor) { this.healthColor = healthColor; }

	public int getHealth() { return health; }
	public void setHealth(int health) { this.health = health; }

	public int getMaxHealth() { return maxHealth; }
	public void setMaxHealth(int maxHealth) { this.maxHealth = maxHealth; }
}

=== ImageGUI ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Displays an image in the scene
 */

package com.corntrip.turnbased.gui;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

public class ImageGUI extends GUIElement
{
	private Image image;
	
	/**
	 * 
	 * @param x: start x
	 * @param y: start y
	 * @param image: image that is being used
	 */
	public ImageGUI(float x, float y, Image image)
	{
		super(x, y);
		this.image = image;
	}

	@Override
	/**
	 * draws the image into the game
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		image.draw(getX() - offsetX, getY() - offsetY);
	}

	// Getters & Setters //
	
	public Image getImage() { return image; }
	public void setImage(Image image) { this.image = image; }
}

=== TextGUI ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Displays text in the scene
 */

package com.corntrip.turnbased.gui;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.TrueTypeFont;

import com.corntrip.turnbased.util.Reference;

public class TextGUI extends GUIElement
{
	private String text;
	private Color textColor;
	private boolean centered = false;
	private TrueTypeFont font;
	
	private int fontWidth = 0;
	
	/**
	 * 
	 * @param x: start x
	 * @param y: start y
	 * @param text: what is displayed
	 * @param textColor: what color the text is
	 */
	public TextGUI(float x, float y, String text, Color textColor)
	{
		super(x, y);
		this.text = text;
		this.textColor = textColor;
		
		font = Reference.FONT_DEFAULT;
		fontWidth = font.getWidth(text);
	}

	@Override
	/**
	 * displays the text into the game
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		gfx.setColor(textColor);
		//centers the text
		if(!centered)
		{
			font.drawString(getX() - offsetX, getY() - offsetY, text, textColor);
		}
		else
		{
			font.drawString(getX() - fontWidth / 2 - offsetX, getY() - offsetY, text, textColor);
		}
	}
	
	// Getters & Setters //
	
	public void setCentered(boolean c) { centered = c; }
	public boolean isCentered() { return centered; }

	public String getText() { return text; }	
	public void setText(String text) 
	{
		this.text = text;
		fontWidth = font.getWidth(text); 
	}

	public Color getTextColor() { return textColor; }
	public void setTextColor(Color textColor) { this.textColor = textColor; }

	public void setFont(TrueTypeFont ttf)
	{
		font = ttf;
		fontWidth = font.getWidth(text);
	}
}

=== ICollidable ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Something that is collidable in the scene with other objects
 */

package com.corntrip.turnbased.physics;

public interface ICollidable
{
	/**
	 * Sees if this collidable object is colliding with another collidable object
	 * @param other The object to check if the collision is happening with
	 * @return true if it is colliding, false if not
	 */
	public boolean collidingWith(ICollidable other);
	
	/**
	 * Checks if the specified position and dimensions would collide with another collidable object
	 * @param other The object to check if the collision is happening with
	 * @param x The x coordinate to check
	 * @param y The y coordinate to check
	 * @param width The width of the area to check
	 * @param height The height of the area to check
	 * @return true if it is colliding, false if not
	 */
	public boolean collidingWith(float x, float y, float width, float height);
	
	// Getters & Setters //
	public float getWidth();
	public float getHeight();
	
	public float getX();
	public float getY();
}

=== Camera ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Just stores variables for the offset and some helpful centering functions
 */

package com.corntrip.turnbased.rendering;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Helper;

public class Camera
{
	private float xOffset, yOffset;
	private float visibleWidth, visibleHeight;
	private float mapWidth, mapHeight;
	
	/**
	 * Creates a Camera Object used to center around a given GameObject using the screen's width & height
	 * @param x The starting x offset of the camera
	 * @param y The starting y offset of the camera
	 * @param vw The screen's width
	 * @param vh The screen's height
	 * @param mw The total area the camera can travel in's width
	 * @param mh The total area the camera can travel in's height
	 */
	public Camera(float x, float y, float vw, float vh, float mw, float mh)
	{
		xOffset = x;
		yOffset = y;
		visibleWidth = vw;
		visibleHeight = vh;
		mapHeight = mh;
		mapWidth = mw;
	}
	
	/**
	 * Puts the object to center around in the center of the camera's viewpoint, but by slowly gliding/slipping there
	 * @param go The GameObject to center around
	 */
	public void slippyCenter(GameObject go)
	{
		float slippyFactor = 0.1f;
		
		xOffset += slippyFactor * (go.getX() - visibleWidth / 2 + go.getWidth() / 2 - xOffset);
		yOffset += slippyFactor * (go.getY() - visibleHeight / 2 + go.getHeight() / 2 - yOffset);
		
		xOffset = Helper.clamp(xOffset, 0, mapWidth - visibleWidth);
		yOffset = Helper.clamp(yOffset, 0, mapHeight - visibleHeight);
	}
	
	/**
	 * Puts the object to center around in the center of the camera's viewpoint
	 * @param go The GameObject to center around
	 */
	public void center(GameObject go)
	{
		if(go == null)
			return;
		xOffset = go.getX() - visibleWidth / 2 + go.getWidth() / 2;
		yOffset = go.getY() - visibleHeight / 2 + go.getHeight() / 2;
		
		xOffset = Helper.clamp(xOffset, 0, mapWidth - visibleWidth);
		yOffset = Helper.clamp(yOffset, 0, mapHeight - visibleHeight);
	}
	
	// Getters & Setters //
	
	public float getXOffset() { return xOffset; }
	public void setXOffset(float xOffset) { this.xOffset = xOffset; }

	public float getYOffset() { return yOffset; }
	public void setYOffset(float yOffset) { this.yOffset = yOffset; }

	public float getScreenWidth() { return visibleWidth; }
	public void setScreenWidth(float screenWidth) { this.visibleWidth = screenWidth; }
	
	public float getScreenHeight() { return visibleHeight; }
	public void setScreenHeight(float screenHeight) { this.visibleHeight = screenHeight; }
}

=== IRenderable ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Something that can be rendered on a scene
 */

package com.corntrip.turnbased.rendering;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

public interface IRenderable
{
	/**
	 * Draws the object at a position on the window
	 * @param gc The main game's container
	 * @param gfx The Graphics object to use to draw
	 * @throws SlickException Potentially thrown when drawing
	 */
	public void render(GameContainer gc, Graphics gfx) throws SlickException;
	
	/**
	 * Draws the object at a specified position on the window
	 * @param gc The main game's container
	 * @param gfx The Graphics object to use to draw
	 * @param offsetX The offset on the x axis to use when drawing the object
	 * @param offsetY The offset on the y axis to use when drawing the object
	 * @throws SlickException Potentially thrown when drawing
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException;
}

=== Helper ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Adds some helpful functions
 */

package com.corntrip.turnbased.util;

public class Helper
{
	/**
	 * Clamps a value between a minimum and a maximum
	 * @param val The value to clamp between the minimum and maximum
	 * @param min The minimum value to constrain the value between
	 * @param max The maximum value to constrain the value between
	 * @return if the value is less than the minimum, the minimum value passed; if it is greator than the max, then the max is returned.  Otherwise the value passed in is returned.
	 */
	public static float clamp(float val, float min, float max)
	{
		if(val < min)
			return min;
		if(val > max)
			return max;
		return val;
	}
	
	/**
	 * Clamps a value between a minimum and a maximum
	 * @param val The value to clamp between the minimum and maximum
	 * @param min The minimum value to constrain the value between
	 * @param max The maximum value to constrain the value between
	 * @return if the value is less than the minimum, the minimum value passed; if it is greator than the max, then the max is returned.  Otherwise the value passed in is returned.
	 */
	public static int clamp(int val, int min, int max)
	{
		if(val < min)
			return min;
		if(val > max)
			return max;
		return val;
	}
	
	/**
	 * Finds the angle in degrees from point A to point B
	 * @param fromX Point A's x coordinate
	 * @param fromY Point A's y coordinate
	 * @param toX Point B's x coordinate
	 * @param toY Point B's y coordinate
	 * @return The angle in degrees from point A to point B
	 */
	public static float getAngle(float fromX, float fromY, float toX, float toY)
	{
		return (float)Math.toDegrees(Math.atan2(toY - fromY, toX - fromX));
	}
	
	public static float getXCoordFromRotation(float rotation, float anchorX, float anchorY, float oldX)
	{
		// Convert to radians because java likes them
		double radians = Math.toRadians(rotation);
		
		// Do fancy maths **not** stolen from stack overflow
		return (float)(Math.cos(radians) * (oldX - anchorX) - Math.sin(radians) * (oldX - anchorY) + anchorX);
	}
	
	public static float getYCoordFromRotation(float rotation, float anchorX, float anchorY, float oldX, float oldY)
	{
		// Convert to radians because java likes them
		double radians = Math.toRadians(rotation);
		
		// Do fancy maths **not** stolen from stack overflow
		return (float)(Math.sin(radians) * (oldX - anchorX) + Math.cos(radians) * (oldY - anchorY) + anchorY);
	}
}

=== Reference ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Stores useful information used across classes
 */

package com.corntrip.turnbased.util;

import java.awt.Color;
import java.awt.Font;

import org.newdawn.slick.TrueTypeFont;

public class Reference
{
	/**
	 * Indicates whether or not the game is currently being debugged
	 */
	public static final boolean DEBUG = false;
	
	/**
	 * The maximum FPS the window should reach
	 */
	public static final int MAX_FPS = 60;
	
	/**
	 * Each tile in the world is 32x32
	 */
	public static final int TILE_DIMENSIONS = 32;
	
	/**
	 * The dimensions of the window
	 */
	public static final int WINDOW_WIDTH = 720, WINDOW_HEIGHT = (int)(WINDOW_WIDTH * 12.0/16);
	
	
	//all colors used when reading in the map
	public static final Color RESOURCE_SPAWN_POINT_KEY = new Color(255, 0, 0);
	public static final Color TREE_SPAWN_KEY           = new Color(0, 255, 0);
	public static final Color WALL_SPAWN_KEY           = new Color(0, 0, 255);
	public static final Color TOWN_HALL_KEY            = new Color(255, 0, 255);
	public static final Color DEPOSIT_KEY              = new Color(0, 0, 0);
	public static final Color PLAYER_KEY               = new Color(255, 255, 0);
	public static final Color TEST_ENEMY               = new Color(255, 0, 128);
	
	//adding in the fonts
	public static final TrueTypeFont FONT_DEFAULT = new TrueTypeFont(new Font("Verdana", Font.PLAIN, 16), true);
	public static final TrueTypeFont FONT_BOLD    = new TrueTypeFont(new Font("Verdana", Font.BOLD , 16), true);
}

=== Resources ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Handles all the resources of the game
 */

package com.corntrip.turnbased.util;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.imageio.ImageIO;

import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.Sound;
import org.newdawn.slick.SpriteSheet;
import org.newdawn.slick.opengl.Texture;
import org.newdawn.slick.util.BufferedImageUtil;

/**
 * Handles all the resources of the game
 */
public class Resources
{
	/**
	 * Stores Images in accordance with their keys
	 */
	private static Map<String, Image> images = new HashMap<>();
	
	/**
	 * Stores SpriteSheets in accordance with their keys
	 */
	private static Map<String, SpriteSheet> spriteSheets = new HashMap<>();
	
	/**
	 * Stores Sounds in accordance with their keys
	 */
	private static Map<String, Sound> sounds = new HashMap<>();
	
	/**
	 * Loads a SpriteSheet found at a given file path starting in res/images/spritesheets/
	 * @param path The path to the file in the res/images/spritesheets/ directory
	 * @return The SpriteSheet found, or null if the file was not found or unable to be parsed
	 */
	public static SpriteSheet loadSpriteSheet(String path, int tileWidth, int tileHeight)
	{
		path = "spritesheets/" + path;
		return new SpriteSheet(loadImage(path), tileWidth, tileHeight);
	}
	
	/**
	 * Loads an Image found at a given file path starting in res/images/
	 * @param path The path to the file in the res/images/ directory
	 * @return The Image found, or null if the file was not found or unable to be parsed
	 */
	public static Image loadImage(String path)
	{
		path = "res/images/" + path;
		Image i = null;
		try
		{			
			// The PNG loader breaks whenever I try and load a png, so I had to do this :(
			BufferedImage bufferedImage = ImageIO.read(new File(path));
		    Texture texture = BufferedImageUtil.getTexture("", bufferedImage);
		    i = new Image(texture.getImageWidth(), texture.getImageHeight());
		    i.setTexture(texture);
		    i.setFilter(Image.FILTER_NEAREST);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
			Logger.getLogger("error").log(Level.SEVERE, "Image [" + path + "] failed to load.", ex);
		}
		return i;
	}
	
	/**
	 * Loads a Sound found at a given file path starting in res/sounds/
	 * @param path The path to the file in the res/sounds/ directory
	 * @return The Sound found, or null if the file was not found or unable to be parsed
	 */
	public static Sound loadSound(String path)
	{
		Sound s = null;
		try
		{
			s = new Sound("res/sounds/" + path);
		}
		catch(SlickException ex)
		{
			Logger.getLogger("error").log(Level.SEVERE, "Sound [" + path + "] failed to load.", ex);
		}
		return s;
	}
	
	/**
	 * Registers a sound that can be found by a given sound name.
	 * @param soundName The String key to recieve the sound by. <b>Note: If a sound with this name already exists it will be overwritten</b>
	 * @param sound The Sound to store
	 */
	public static void registerSound(String soundName, Sound sound)
	{
		sounds.put(soundName, sound);
	}
	
	/**
	 * Registers an image that can be found by a given image name.
	 * @param imageName The String key to recieve the image by. <b>Note: If an image with this name already exists it will be overwritten</b>
	 * @param img The Image to store
	 */
	public static void registerImage(String imageName, Image img)
	{
		images.put(imageName, img);
	}
	
	/**
	 * Registers a spritesheet that can be found by a given sound name.
	 * @param soundName The String key to recieve the spritesheet by. <b>Note: If a spritesheet with this name already exists it will be overwritten</b>
	 * @param sound The SpriteSheet to store
	 */
	public static void registerSpriteSheet(String spriteSheetName, SpriteSheet sheet)
	{
		spriteSheets.put(spriteSheetName, sheet);
	}
	
	/**
	 * Returns the Sound found at the given String key
	 * @param name The key the Sound is stored at
	 * @return The Sound found at the given String key if found, null if not present.
	 */
	public static Sound getSound(String name)
	{
		return sounds.get(name);
	}
	
	/**
	 * Returns the SpriteSheet found at the given String key
	 * @param name The key the SpriteSheet is stored at
	 * @return The SpriteSheet found at the given String key if found, null if not present.
	 */
	public static SpriteSheet getSpriteSheet(String name)
	{
		return spriteSheets.get(name);
	}
	
	/**
	 * Returns the Image found at the given String key
	 * @param name The key the Image is stored at
	 * @return The Image found at the given String key if found, null if not present.
	 */
	public static Image getSpriteImage(String name, int x, int y)
	{
		return spriteSheets.get(name).getSubImage(x, y);
	}
	
	/**
	 * Returns the Image found at the given String key
	 * @param name The key the Image is stored at
	 * @return The Image found at the given String key if found, null if not present.
	 */
	public static Image getImage(String name)
	{
		return images.get(name);
	}
	
	/**
	 * Registers an image by the file and registers it with the given name
	 * @param name The name to register the image with
	 * @param location The file of the image
	 */
	public static void registerImage(String name, String location)
	{
		registerImage(name, Resources.loadImage(location));
	}
	
	/**
	 * Registers a SpriteSheet by the file and registers it with the given name
	 * @param name The name to register the image with
	 * @param location The file of the image
	 */
	public static void registerSpriteSheet(String name, String location, int w, int h)
	{
		registerSpriteSheet(name, Resources.loadSpriteSheet(location, w, h));
	}
	
	/**
	 * Registers a Sound by the file and registers it with the given name
	 * @param name The name to register the image with
	 * @param location The file of the image
	 */
	public static void registerSound(String name, String location)
	{
		registerSound(name, Resources.loadSound(location));
	}
}

=== Tile ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * A background Tile in the scene
 */

package com.corntrip.turnbased.world;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.rendering.IRenderable;

public class Tile implements IRenderable
{
	private float x, y;
	private float width, height;
	
	private Image texture;

	/**
	 * A simple thing to render
	 * @param x The x position to draw at
	 * @param y The y position to draw at
	 * @param w The width of the tile to draw
	 * @param h The height of the tile to draw
	 */
	public Tile(float x, float y, float w, float h, Image texture)
	{
		this.x = x;
		this.y = y;
		this.width = w;
		this.height = h;
		this.texture = texture;
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	/**
	 * draws the tile into the world
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		texture.draw(x - offsetX, y - offsetY);
	}

	// Getters & Setters //
	
	public float getX() { return x; }
	public void setX(float x) { this.x = x; }

	public float getY() { return y; }
	public void setY(float y) { this.y = y; }

	public float getWidth() { return width; }
	public void setWidth(float width) { this.width = width; }

	public float getHeight() { return height; }
	public void setHeight(float height) { this.height = height; }
}

=== World ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Stores everything in a given scene and updates & renders them
 */

package com.corntrip.turnbased.world;

import java.util.ArrayList;
import java.util.List;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.living.Enemy;
import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.living.TestEnemy;
import com.corntrip.turnbased.gameobject.nonliving.townhall.Townhall;
import com.corntrip.turnbased.rendering.Camera;
import com.corntrip.turnbased.rendering.IRenderable;
import com.corntrip.turnbased.util.Helper;
import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;

public class World implements IRenderable
{	
	/**
	 * Keeps track of the Entity to be treated as the player
	 */
	private LivingEntity player = null;
	
	/**
	 * Keeps track of the GameObject to be treated as the town hall
	 */
	private Townhall townhall = null;
	
	/**
	 * Every GameObject in the scene (including Entities) is stored in here
	 */
	private List<GameObject> gameObjects = new ArrayList<>();
	
	/**
	 * Every Entity in the scene is stored here (each entity will also have a copy in the gameObjects List)
	 */
	private List<Entity> entities = new ArrayList<>();
	
	/**
	 * The Camera used when rendering the world; if no player is defined it simply remains in its default position
	 */
	private Camera cam;
	
	/**
	 * Keeps track of which wave of enemies it is on
	 */
	private int wave = 1;
	
	/**
	 * The dimensions of the world
	 */
	private final int WIDTH, HEIGHT;
	
	/**
	 * Every tile in the world
	 */
	private Tile[][] tiles;
	
	/**
	 * Keeps track of objects to be removed after being messed with
	 */
	private List<GameObject> objectsToBeRemoved = new ArrayList<>();
	
	/**
	 * Keeps track of the score
	 */
	private int score;
	
	/**
	 * A world holds every object in a scene and handles rendering and updating them all
	 * @param width The total width of the world
	 * @param height The total height of the world
	 */
	public World(int width, int height)
	{
		WIDTH = width;
		HEIGHT = height;
		
		int tilesAmtY = HEIGHT / Reference.TILE_DIMENSIONS;
		int tilesAmtX = WIDTH  / Reference.TILE_DIMENSIONS;
		
		tiles = new Tile[tilesAmtY][tilesAmtX];
		
		// Fills the tiles
		for(int ty = 0; ty < tilesAmtY; ty++)
		{
			for(int tx = 0; tx < tilesAmtX; tx++)
			{
				tiles[ty][tx] = new Tile(tx * Reference.TILE_DIMENSIONS, ty * Reference.TILE_DIMENSIONS, 
											Reference.TILE_DIMENSIONS, Reference.TILE_DIMENSIONS, 
											Resources.getSpriteImage("tiles", (int)(Math.random() + 0.5), (int)(Math.random() + 0.5)));
			}
		}
		
		if(Reference.DEBUG)
			System.out.println("Total Tiles: " + tiles.length * tiles[0].length);
		
		cam = new Camera(0, 0, Reference.WINDOW_WIDTH, Reference.WINDOW_HEIGHT, WIDTH, HEIGHT);
	}
	
	/**
	 * Renders each object in the world with a specified offset added to the camera's offset
	 */
	@Override
	public void render(GameContainer gc, Graphics gfx, float passedXOff, float passedYOff) throws SlickException
	{
		float camXOff = cam.getXOffset();
		float camYOff = cam.getYOffset();
		
		//renders the intial tiles, aka the grass
		for(int y = (int) (camYOff / Reference.TILE_DIMENSIONS); y < (camYOff + cam.getScreenHeight()) / Reference.TILE_DIMENSIONS && y < HEIGHT / Reference.TILE_DIMENSIONS; y++)
		{
			for(int x = (int) (camXOff / Reference.TILE_DIMENSIONS); x < (camXOff + cam.getScreenWidth()) / Reference.TILE_DIMENSIONS && x < WIDTH / Reference.TILE_DIMENSIONS; x++)
			{
				tiles[y][x].render(gc, gfx, camXOff, camYOff);
			}
		}
		
		//draws anything not in the inital camera (I think)
		for(GameObject o : gameObjects)
		{
			if(getPlayer() != null && !o.equals(getPlayer()))
			{
				if(o.getX() + o.getWidth() > cam.getXOffset() && o.getX() < cam.getXOffset() + cam.getScreenWidth())
				{
					if(o.getY() + o.getHeight() > cam.getYOffset() && o.getY() < cam.getYOffset() + cam.getScreenHeight())
					{
						gfx.pushTransform(); // Makes sure this drawing doesn't mess w/ any others
						o.render(gc, gfx, camXOff + passedXOff, camYOff + passedYOff);
						gfx.popTransform();
					}
				}
			}
		}
		
		if(getPlayer() != null) // Render the player last so it's not behind walls n stuff
			getPlayer().render(gc, gfx, camXOff + passedXOff, camYOff + passedYOff);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	/*
	 * updates all the entities and centers the camera as well as removing dead items
	 */
	public void update(GameContainer gc, int delta) throws SlickException
	{
		//updates game objects
		for(int i = 0;  i < entities.size(); i++)
		{
			Entity e = entities.get(i);
			e.update(gc, delta);
		}
		
		//centers camera
		if(player != null)
			cam.slippyCenter(player);
		
		//removes objects
		while(objectsToBeRemoved.size() > 0)
		{
			GameObject go = objectsToBeRemoved.remove(0);
			removeObjectUnsafely(go);
		}
	}
	
	/**
	 * Spawns the enemies into the world and out of the camera
	 */
	public void spawnEnemies()
	{
		int enemyW = 32;
		int enemyH = 32;
		
		int numOfEnemies = (int)Math.pow(6, wave * 0.5);
		
		for(int i = 0; i < numOfEnemies; i++)
		{
			float x, y;
			
			// Loop for searching for a good position
			searchLoop:
			do
			{
				x = (float) (Math.random() * WIDTH);
				y = (float) (Math.random() * HEIGHT);
				
				// Make sure it's not colliding with any objects in the scene
				for(GameObject go : gameObjects)
				{
					if(go.collidingWith(x, y, enemyW, enemyH))
					{
						continue searchLoop;
					}
				}
			} 
			// Makes sure it won't spawn in the player's viewpoint
			while(x + enemyW >= cam.getXOffset() && x <= cam.getXOffset() + cam.getScreenWidth() 
				 && y + enemyH >= cam.getYOffset() && y <= cam.getYOffset() + cam.getScreenHeight()); 
			
			Enemy e = new TestEnemy(x, y, enemyW, enemyH, this, getPlayer(), "Evil Ghost", Helper.clamp((int)Math.ceil(wave * Math.random()), 1, 5));
			
			addObject(e);
		}
	}
	
	/**
	 * Tells the world who to center the camera on and other things that are player-specific. This also adds the player to the object list.
	 * @param ent The Entity to treat as the player
	 */
	public void setPlayer(LivingEntity ent)
	{
		player = ent;
		cam.center(player);
		addObject(player);
	}
	
	/**
	 * Assigns the town hall in the world to be the given object, and adds it to the world's registered objects.
	 * @param th The Townhall to be added
	 */
	public void setTownhall(Townhall th)
	{
		addObject(th);
		townhall = th;
	}
	
	/**
	 * Adds an object to be handled by the world
	 * @param obj The object to add to the world
	 */
	public void addObject(GameObject obj)
	{
		if(obj instanceof Entity)
			entities.add((Entity)obj);
		
		gameObjects.add(obj);
	}
	
	/**
	 * Removes an object from the world after the world is done updating
	 * @param obj The object to remove
	 */
	public void removeObject(GameObject obj)
	{
		objectsToBeRemoved.add(obj);
	}
	
	/**
	 * Removes an object from the world after the world is done updating
	 * @param obj The object's index to remove
	 */
	public void removeObject(int i)
	{
		objectsToBeRemoved.add(gameObjects.get(i));
	}
	
	/**
	 * Removes an object from the world regardless of if things are updating or not
	 * @param obj The object to remove
	 */
	private void removeObjectUnsafely(GameObject obj)
	{
		gameObjects.remove(obj);
		if(obj instanceof Entity)
			entities.remove(obj);
		
		if(getPlayer() != null && getPlayer().equals(obj))
			setPlayer(null);
		else if(getTownhall() != null && getTownhall().equals(obj))
			setTownhall(null);
	}
	
	/**
	 * Sees if the world's objects has the item
	 * @param obj: object being checked
	 * @return
	 */
	public boolean containsObject(GameObject obj)
	{
		for(GameObject o : gameObjects)
			if(o.equals(obj))
				return true;
		return false;
	}
	
	/*
	 * starts the next wave of enemies
	 */
	public void initateNextWave()
	{
		if(Reference.DEBUG)
			System.out.println("spawning");
		spawnEnemies();
		wave++;
	}
	
	// Getters & Setters //
	
	public int getWave() { return wave; }
	
	public List<GameObject> getGameObjects() { return gameObjects; }
	public List<Entity> getEntities() { return entities; }
	
	public LivingEntity getPlayer() { return player; }
	
	public Townhall getTownhall() { return townhall; }

	public float getWidth() { return WIDTH; }
	public float getHeight() { return HEIGHT; }

	public int getScore() { return score; }
	public void setScore(int score) { this.score = score; }
	public void addToScore(int amt) { this.score += amt; }
}

=== WorldLoader ===
/*
 * Anthony Tornetta & Troy Cope | P5 | 3/31/18
 * This is our own work: ACT & TC
 * Creates a new World object based off an image
 */

package com.corntrip.turnbased.world;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

import com.corntrip.turnbased.gameobject.living.Enemy;
import com.corntrip.turnbased.gameobject.living.Player;
import com.corntrip.turnbased.gameobject.nonliving.Tree;
import com.corntrip.turnbased.gameobject.nonliving.Wall;
import com.corntrip.turnbased.gameobject.nonliving.resources.GoldResource;
import com.corntrip.turnbased.gameobject.nonliving.resources.ResourceDeposit;
import com.corntrip.turnbased.gameobject.nonliving.resources.ResourceGenerator;
import com.corntrip.turnbased.gameobject.nonliving.townhall.Townhall;
import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;

public class WorldLoader
{
	public static World generateWorldFromImage(BufferedImage img)
	{
		//intialization of a world
		World world = new World(img.getWidth() * Reference.TILE_DIMENSIONS, img.getHeight() * Reference.TILE_DIMENSIONS);
		
		final int w = Reference.TILE_DIMENSIONS, h = Reference.TILE_DIMENSIONS;
		
		List<Enemy> enemies = new ArrayList<>();
		
		//scanning of the map's image and comparing of each individual color
		for(int y = 0; y < img.getHeight(); y++)
		{
			for(int x = 0; x < img.getWidth(); x++)
			{
				Color c = new Color(img.getRGB(x, y));
				
				//all squares and in terms of tiles
				final float actualX = x * w;
				final float actualY = y * h;
				
				//big if statementes to generate all the items from the paint image
				//basically compares color code to the drawn map
				if(c.equals(Reference.RESOURCE_SPAWN_POINT_KEY))
				{
					world.addObject(new ResourceGenerator(actualX, actualY, w * 2, h * 2, world, 10000, 
							new GoldResource(actualX + w / 2, actualY + h / 2, w, h)));
				}
				else if(c.equals(Reference.TREE_SPAWN_KEY))
				{
					world.addObject(new Tree(actualX, actualY, w * 2, h * 3));
				}
				else if(c.equals(Reference.WALL_SPAWN_KEY))
				{
					world.addObject(new Wall(actualX, actualY, w, h, 
										Resources.getImage("wall")));
				}
				else if(c.equals(Reference.TOWN_HALL_KEY))
				{
					world.setTownhall(new Townhall(actualX, actualY, w * 4, h * 4));
				}
				else if(c.equals(Reference.PLAYER_KEY))
				{
					world.setPlayer(new Player(actualX, actualY, w, h, world));
				}
				else if(c.equals(Reference.DEPOSIT_KEY))
				{
					world.addObject(new ResourceDeposit(actualX, actualY, w, h));
				}
			}
		}
		
		//sets all the enemies to the player
		for(Enemy e : enemies)
		{
			e.setTarget(world.getPlayer());
		}
		
		return world;
	}
}
