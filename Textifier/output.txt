
=== GameNameHere ===
package com.corntrip.turnbased;

import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;

import org.newdawn.slick.AppGameContainer;
import org.newdawn.slick.BasicGame;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;
import com.corntrip.turnbased.world.WorldLoader;

public class GameNameHere extends BasicGame
{
	private World world;
	
	public GameNameHere()
	{
		super("a (good?) game.");
	}
	
	public static void main(String[] args)
	{
		try
        {
            AppGameContainer app = new AppGameContainer(new GameNameHere());
            app.setDisplayMode(Reference.WINDOW_WIDTH, Reference.WINDOW_HEIGHT, false);
            app.start();
        }
        catch (SlickException e)
        {
            e.printStackTrace();
        }
	}

	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		gfx.clear();
		world.render(gc, gfx);
	}
	
	@Override
	public void init(GameContainer gc) throws SlickException
	{
		gc.setMaximumLogicUpdateInterval(Reference.MAX_FPS);
		gc.setTargetFrameRate(Reference.MAX_FPS);
		gc.setAlwaysRender(true);
		gc.setShowFPS(Reference.DEBUG);
		gc.setVSync(true);
		
		initializeResources();
		
		try
		{
			world = WorldLoader.generateWorldFromImage(ImageIO.read(new File("res/maps/map.png")));
		}
		catch (IOException e)
		{
			e.printStackTrace();
			throw new IllegalStateException("Failed to Create World.");
		}
	}
	
	private void initializeResources()
	{
		registerSpriteSheet("tiles", "tiles.png", Reference.TILE_DIMENSIONS, Reference.TILE_DIMENSIONS);
		
		registerImage("player", "player.png");
		registerImage("bow", "bow.png");
		registerImage("arrow", "arrow.png");
		registerImage("sword", "sword.png");
		registerImage("wall", "wall.png");
		registerImage("enemy", "enemy.png");
		registerImage("tree", "tree.png");
		registerImage("gold", "gold.png");
		registerImage("deposit", "resource-deposit.png");
		registerImage("generator", "resource-generator.png");
		registerImage("townhall", "townhall.png");
	}
	
	private void registerImage(String name, String location)
	{
		Resources.registerImage(name, Resources.loadImage(location));
	}
	
	private void registerSpriteSheet(String name, String location, int w, int h)
	{
		Resources.registerSpriteSheet(name, Resources.loadSpriteSheet(location, w, h));
	}
	
	@SuppressWarnings("unused")
	private void registerSound(String name, String location)
	{
		Resources.registerSound(name, Resources.loadSound(location));
	}

	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		world.update(gc, delta);
	}
}

=== Entity ===
package com.corntrip.turnbased.gameobject;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.world.World;

public abstract class Entity extends GameObject
{
	/**
	 * For getting to know your surroundings
	 */
	private World world;
	
	/**
	 * A GameObject that has an update function that runs every game tick
	 * @param startX The starting x of the object
	 * @param startY The starting y of the object
	 * @param w The width of the object
	 * @param h The height of the object
	 * @param world The world the entity is in
	 */
	public Entity(float startX, float startY, float w, float h, World world)
	{
		super(startX, startY, w, h);
		
		this.world = world;
	}
	
	/**
	 * Called every game tick<br>
	 * This should NOT be used for rendering (but I guess you can if u really want)<br>
	 * Put any logic that needs to be called every frame in here
	 * @param gc The GameContainer this is being called from
	 * @param delta The total time passed since the last call
	 * @throws SlickException If something bad were to happen
	 */
	public abstract void update(GameContainer gc, int delta) throws SlickException;
	
	// Getters & Setters //
	
	public World getWorld() { return world; }
	public void setWorld(World w) { this.world = w; }
}

=== GameObject ===
package com.corntrip.turnbased.gameobject;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.physics.ICollidable;
import com.corntrip.turnbased.rendering.IRenderable;

public abstract class GameObject implements ICollidable, IRenderable, Cloneable
{
	/**
	 * Used to differentiate between objects
	 */
	private long objectId;
	
	/**
	 * Incremented every time a new GameObject is created.
	 * This allows for each object to have a unique id to differentiate it from objects of the same type.
	 */
	private static long masterId = 0;
	
	/**
	 * Position of the object
	 */
	private float x, y;
	
	/**
	 * Dimensions of the object
	 */
	private float width, height;
	
	private float rotation = 0;
	
	/**
	 * The most general form of something in the game scene.<br>
	 * @param startX The x the object will start at
	 * @param startY The y the object will start at
	 * @param w The width of the object
	 * @param h The height of the object
	 */
	public GameObject(float startX, float startY, float w, float h)
	{
		objectId = masterId;
		masterId++;
		
		x = startX;
		y = startY;
		
		width = w;
		height = h;
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public boolean collidingWith(ICollidable other)
	{
		return collidingWith(other.getX(), other.getY(), other.getWidth(), other.getHeight());
	}
	
	@Override
	public boolean collidingWith(float x, float y, float width, float height)
	{
		if(x + width >= getX() && x <= getX() + getWidth())
		{
			if(y + height >= getY() && y <= getY() + getHeight())
			{
				return true;
			}
		}
		return false;
	}
	
	@Override
	public boolean equals(Object other)
	{
		if(other instanceof GameObject)
		{
			return ((GameObject)other).getObjectId() == getObjectId();
		}
		return false;
	}
	
	// Getters & Setters //
	
	@Override
	public float getWidth() { return width; }
	@Override
	public float getHeight() { return height; }
	@Override
	public float getX() { return x; }
	@Override
	public float getY() { return y; }
	
	public void setX(float x) { this.x = x; }
	public void setY(float y) { this.y = y; }
	public void setWidth(float w) { this.width = w; }
	public void setHeight(float h) { this.height = h; }
	
	public float getRotation()
	{
		return rotation;
	}
	
	public void setRotation(float rotation)
	{
		setRotation(rotation, getAnchorPointX(), getAnchorPointY());
	}
	
	public void setRotation(float rotation, float anchorX, float anchorY)
	{
		this.rotation = rotation;
	}	
	public long getObjectId() { return objectId; }
	
	public float getAnchorPointX() { return getAnchorPointX(0); }
	public float getAnchorPointY() { return getAnchorPointY(0); }
	public float getAnchorPointX(float off) { return getX() + getWidth() / 2 - off; }
	public float getAnchorPointY(float off) { return getY() + getHeight() / 2 - off; }
}

=== Enemy ===
package com.corntrip.turnbased.gameobject.living;

import com.corntrip.turnbased.world.World;

public abstract class Enemy extends LivingEntity
{
	/**
	 * The target to go after
	 */
	private LivingEntity target;
	
	/**
	 * The Antagonist of the story
	 * @param startX The starting x of the enemy
	 * @param startY The starting y of the enemy
	 * @param w The width of the player
	 * @param h The height of the player
	 * @param world The world the enemy is in
	 * @param target The target for the enemy (doesn't have to be the player)
	 */
	public Enemy(float startX, float startY, float w, float h, World world, LivingEntity target)
	{
		super(startX, startY, w, h, world, 2);
		
		this.target = target;
	}
	
	// Getters & Setters //
	
	public LivingEntity getTarget() { return target; }
	public void setTarget(LivingEntity t) { this.target = t; }
}

=== LivingEntity ===
package com.corntrip.turnbased.gameobject.living;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.world.World;

public abstract class LivingEntity extends Entity implements Cloneable
{
	private int maxHealth;
	private int health;
	
	/**
	 * An Entity but with health and a clone function
	 * @param startX The x position it starts at
	 * @param startY THe y position it starts at
	 * @param w The width of the LivingEntity
	 * @param h The height of the LivingEntity
	 * @param world The world the entity is in
	 */
	public LivingEntity(float startX, float startY, float w, float h, World world, int maxHealth)
	{
		super(startX, startY, w, h, world);
		health = maxHealth;
		this.maxHealth = maxHealth;
	}
	
	/**
	 * Heals the LivingEntity a given amount
	 * @param amt The amount to heal it by
	 */
	public void heal(int amt)
	{
		health += amt;
	}
	
	/**
	 * Deals damage to the LivingEntity, and if the health <= 0 it dies
	 * @param amt
	 */
	public void takeDamage(int amt)
	{
		health -= amt;
		if(health <= 0)
			die();
	}
	
	/**
=	 * Removes the LivingEntity from the world
	 */
	public void die()
	{
		getWorld().removeObject(this);
	}
	
	@Override
	public abstract LivingEntity clone();
	
	public int getMaxHealth() { return maxHealth; }
	public void setMaxHealth(int maxHealth) { this.maxHealth = maxHealth; }
	
	public int getHealth() { return health; }
	public void setHealth(int health) { this.health = health; }
}

=== Player ===
package com.corntrip.turnbased.gameobject.living;

import java.util.List;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.Input;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.modifier.equips.Bow;
import com.corntrip.turnbased.gameobject.modifier.equips.SwungWeapon;
import com.corntrip.turnbased.gameobject.modifier.equips.Weapon;
import com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil.Projectile;
import com.corntrip.turnbased.gameobject.nonliving.resources.Resource;
import com.corntrip.turnbased.gameobject.nonliving.resources.ResourceDeposit;
import com.corntrip.turnbased.gameobject.nonliving.townhall.Townhall;
import com.corntrip.turnbased.gui.GUIElement;
import com.corntrip.turnbased.gui.HealthBarGUI;
import com.corntrip.turnbased.gui.ImageGUI;
import com.corntrip.turnbased.gui.TextGUI;
import com.corntrip.turnbased.util.Helper;
import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;

public class Player extends LivingEntity
{
	/**
	 * Used for calculating movement
	 */
	private float velX = 0, velY = 0;
	
	/**
	 * Holds the points aquired from scoring resources
	 */
	private int pts = 0;
	
	/**
	 * Holds the resource the player may or may not be carrying
	 */
	private Resource resourceCarrying = null;
	
	/**
	 * A flag to tell if the upgrade GUI should be displayed
	 */
	private boolean displayUpgradeGUI = false;
	
	/**
	 * The texture of the player
	 */
	private Image texture = Resources.getImage("player");
	
	/**
	 * Max velocity the player should move
	 */
	private static final float MAX_MOVE_SPEED = 5.0f;
	
	/**
	 * A healthbar to display
	 */
	private HealthBarGUI healthBar;
	
	private TextGUI txt;
	
	private ImageGUI[] upgradeSlots = new ImageGUI[3];
	
	private Weapon weapon;
	
	/**
	 * Controllable Entity by the user
	 * @param startX The x to start the player at
	 * @param startY The y to start the player at
	 * @param w The width of the player
	 * @param h The height of the player
	 * @param world The world the player is in
	 */
	public Player(float startX, float startY, float w, float h, World world)
	{
		super(startX, startY, w, h, world, 20);
		
		healthBar = new HealthBarGUI(getX(), getY() - 8, getWidth(), 6, Color.red, Color.green, getHealth(), getMaxHealth());
		txt = new TextGUI(getX(), getY() - 20, "Joe Shmoe", Color.red);
		txt.setCentered(true);
		
		setHealth(getHealth());
		healthBar.setHealth(getHealth());
		
		upgradeSlots[0] = new ImageGUI(0, 0, Resources.getImage("player"));
		upgradeSlots[1] = new ImageGUI(0, 0, Resources.getImage("player"));
		upgradeSlots[2] = new ImageGUI(0, 0, Resources.getImage("player"));
		
		weapon = new Bow(this, Resources.getImage("bow"), 1);
		//weapon = new Sword(getX() + getWidth(), getY(), 32, 32, this, Resources.getImage("sword"), 1);//new Bow(this, Resources.getImage("bow"));
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		weapon.update(delta);
		
		float subVal = 0.8f;
		float moveBy = Reference.MAX_FPS * delta / 1000.0f;
		
		velX -= Math.signum(velX) * subVal * moveBy;
		velY -= Math.signum(velY) * subVal * moveBy;
		
		// If the velocities are somewhere near 0, just set them to 0 so it doesn't slide forever
		if(velX <= subVal && velX >= -subVal)
			velX = 0;
		if(velY <= subVal && velY >= -subVal)
			velY = 0;
		
		// Fun movement calcs in here
		
		Input in = gc.getInput();
		if(in.isKeyDown(Input.KEY_W) || in.isKeyDown(Input.KEY_UP))
			velY += -2.0f * moveBy;
		if(in.isKeyDown(Input.KEY_S) || in.isKeyDown(Input.KEY_DOWN))
			velY += 2.0f * moveBy;
		
		if(in.isKeyDown(Input.KEY_A) || in.isKeyDown(Input.KEY_LEFT))
			velX += -2.0f * moveBy;
		if(in.isKeyDown(Input.KEY_D) || in.isKeyDown(Input.KEY_RIGHT))
			velX += 2.0f * moveBy;
		
		
		if(in.isMouseButtonDown(Input.MOUSE_LEFT_BUTTON))
		{
			weapon.attack();
		}
		// End movement calcs
				
		if(resourceCarrying == null)
		{
			velX = Helper.clamp(velX, -MAX_MOVE_SPEED, MAX_MOVE_SPEED);
			velY = Helper.clamp(velY, -MAX_MOVE_SPEED, MAX_MOVE_SPEED);
		}
		else
		{
			velX = Helper.clamp(velX, -MAX_MOVE_SPEED / 3, MAX_MOVE_SPEED / 3);
			velY = Helper.clamp(velY, -MAX_MOVE_SPEED / 3, MAX_MOVE_SPEED / 3);
		}
		
		float newX = velX + getX();
		float newY = velY + getY();
		
		List<GameObject> objs = getWorld().getGameObjects();
		for(int i = 0; i < objs.size(); i++)
		{
			if(!objs.get(i).equals(this))
			{
				GameObject go = objs.get(i);
				
				if(go instanceof Townhall)
				{
					Townhall th = (Townhall)go;
					if(th.withinRange(this))
						displayUpgradeGUI = true;
					else
						displayUpgradeGUI = false;
				}
				
				if(go.collidingWith(newX, newY, getWidth(), getHeight()))
				{
					if(go instanceof ResourceDeposit)
					{
						if(resourceCarrying != null)
						{
							scoreResource(resourceCarrying);
							resourceCarrying = null;
						}
					}
					else if(go instanceof Resource)
					{
						if(resourceCarrying == null)
						{
							resourceCarrying = (Resource) go;
							getWorld().removeObject(go);
						}
					}
					else
					{
						if(go.collidingWith(newX, newY, getWidth(), getHeight()))
						{
							if(go instanceof Projectile)
							{
								Projectile proj = (Projectile)go;
								if(proj.getWeapon().getOwner().equals(this))
								{
									continue;
								}
							}
							
							float oldX = getX();
							float oldY = getY();
							
							final float FACTOR = 0.001f; // the lower this is the more precise but the more iterations - this is a decent value
							
							float difX = newX - oldX;
							float difY = newY - oldY;
							
							while(go.collidingWith(getX() + difX, getY(), getWidth(), getHeight()))
								difX -= Math.signum(velX) * FACTOR;
							while(go.collidingWith(getX(), getY() + difY, getWidth(), getHeight()))
								difY -= Math.signum(velY) * FACTOR;								
							
							newX = getX() + difX;
							newY = getY() + difY;
						}
					}
				}
			}
		}
		
		if(newX != getX() + velX) // If the newX is not equal to the original calculation, the object collided into something causing it to change
			velX = 0; // Since you just rammed into something, I don't think your going in that direction any more
		if(newY != getY() + velY)
			velY = 0;
		
		setX(newX);
		setY(newY);
		
		setX(Helper.clamp(getX(), 0, getWorld().getWidth() - getWidth()));
		setY(Helper.clamp(getY(), 0, getWorld().getHeight() - getHeight()));
		
		if(weapon instanceof SwungWeapon)
		{
			SwungWeapon sw = (SwungWeapon)weapon;
			
			// you have no idea
			// how long
			// it took me
			// to figure out
			// these big maths.
			// i have pictures.
			// i will show you said pictures.
			
			sw.setX(getX() + Helper.clamp(-2 * (Math.abs(getRotation()) / 90) + 2 * getWidth(), -1, 1));
			sw.setY(getY() + ((getRotation() % 45) / 45.0f) * getHeight());
		}
		
		healthBar.setX(getX());
		healthBar.setY(getY() - 16);
		healthBar.setHealth(getHealth());
		
		txt.setX(getX() + getWidth() / 2);
		txt.setY(getY() - 46);
		
		upgradeSlots[0].setX(getX() - 48);
		upgradeSlots[0].setY(getY() - 128);
		upgradeSlots[1].setX(getX());
		upgradeSlots[1].setY(getY() - 128);
		upgradeSlots[2].setX(getX() + 48);
		upgradeSlots[2].setY(getY() - 128);
		
		if(getWorld().getTownhall().withinRange(this))
		{
			displayUpgradeGUI = true;
		}
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{		
		gfx.setColor(Color.green);
		
		// For rotation
		Input input = gc.getInput();
		int mouseX = input.getMouseX();
		int mouseY = input.getMouseY();
		
		float anchorX = getAnchorPointX(offsetX);
		float anchorY = getAnchorPointY(offsetY);
		
		healthBar.render(gc, gfx, offsetX, offsetY);
		txt.render(gc, gfx, offsetX, offsetY);
		
		if(displayUpgradeGUI)
		{
			for(GUIElement elem : upgradeSlots)
			{
				elem.render(gc, gfx, offsetX, offsetY);
			}
		}
		
		setRotation(Helper.getAngle(anchorX, anchorY, mouseX, mouseY));
		
		gfx.setColor(Color.green);
		if(Reference.DEBUG)
			gfx.drawLine(anchorX, anchorY, input.getMouseX(), input.getMouseY());
		
		gfx.rotate(anchorX, anchorY, getRotation());
		
		float drawX = getX() - offsetX;
		float drawY = getY() - offsetY;
		texture.draw(drawX, drawY);
		
		weapon.renderAt(gc, gfx, drawX + getWidth(), drawY);
	}
	
	private void scoreResource(Resource r)
	{
		if(r != null)
			pts += r.getPtsValue();
	}
	
	@Override
	public LivingEntity clone()
	{
		return new Player(getX(), getY(), getWidth(), getHeight(), getWorld());
	}
	
	public int getPoints() { return pts; }
	public void setPoints(int p) { pts = p; }
}

=== TestEnemy ===
package com.corntrip.turnbased.gameobject.living;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gui.HealthBarGUI;
import com.corntrip.turnbased.util.Helper;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;

public class TestEnemy extends Enemy
{
	private HealthBarGUI hb;
	private Image img;
	
	public TestEnemy(float startX, float startY, float w, float h, World world, LivingEntity target)
	{
		super(startX, startY, w, h, world, target);
		
		img = Resources.getImage("enemy");
		
		hb = new HealthBarGUI(getX(), getY() - 16, getWidth(), 6, Color.red, Color.green, getMaxHealth(), getMaxHealth());
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		hb.render(gc, gfx, offsetX, offsetY);
		
		gfx.setColor(Color.red);
		gfx.rotate(getAnchorPointX(offsetX), getAnchorPointY(offsetY), getRotation());
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		LivingEntity target = getTarget();
		
		if(target != null) // the target has been set
		{
			float targetX = target.getX();
			float targetY = target.getY();
			
			float xd = Helper.clamp(targetX - getX(), -1, 1);
			float xdy = Helper.clamp(targetY - getY(), -1, 1);
			
			float moveX = (float)Math.random() * 10 - 5 + xd;
			float moveY = (float)Math.random() * 10 - 5 + xdy;
			
			setX(getX() + moveX);
			setY(getY() + moveY);
			
			setRotation(Helper.getAngle(getAnchorPointX(), getAnchorPointY(), target.getAnchorPointX(), target.getAnchorPointY()));
			
			if(this.collidingWith(target))
			{
				getWorld().removeObject(this);
				target.takeDamage(1);
			}
		}
		
		hb.setHealth(getHealth());
		hb.setX(getX());
		hb.setY(getY() - 16);
	}

	@Override
	public LivingEntity clone()
	{
		return new TestEnemy(getX(), getY(), getWidth(), getHeight(), getWorld(), getTarget());
	}
}

=== Equipable ===
package com.corntrip.turnbased.gameobject.modifier;

import org.newdawn.slick.Image;

public abstract class Equipable
{	
	public abstract Image getImage();
}
//tacking on swords and stuff

=== Modified ===
package com.corntrip.turnbased.gameobject.modifier;
import com.corntrip.turnbased.gameobject.living.LivingEntity;

public abstract class Modified
{
	LivingEntity assigned = null;
	//get and sets to what it's assigned
	public  void setAssinged(LivingEntity a)
	{
		assigned = a;
	}
	public LivingEntity getAssigned()
	{
		return assigned;
	}
	
	//lol we can have epic trees and super entities like bosses
	public abstract void modifyStats(LivingEntity a);
	
	//changes name
	public abstract String modifiedName(String n);
}

=== HPMod ===
package com.corntrip.turnbased.gameobject.modifier.entityAddition;

import java.util.ArrayList;

import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.modifier.Modified;

/*
 * During unit spawn there should be a ArrayList of these bad boys and it should have a random chance to spawn a boss
 * Which then links it to a new Creation of one of these
 */


public class HPMod extends Modified
{

	private ArrayList<String> modNames;
	
	HPMod()
	{
		modNames = new ArrayList<String>();
		modNames.add("Giant");
		modNames.add("Huge");
		modNames.add("Gigantic");
		modNames.add("Large");
		modNames.add("Big");
	}
	
	public void modifyStats(LivingEntity a)
	{
		a.setHealth(a.getHealth() + 10);
	}

	/* 
	 * n: simply the name before
	 * a: list of possible modifiers
	 */
	public String modifiedName(String n) 
	{
		return modNames.get((int)(Math.random()*modNames.size())) + " " + n;
	}

}

=== Bow ===
package com.corntrip.turnbased.gameobject.modifier.equips;

import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil.Arrow;
import com.corntrip.turnbased.util.Resources;

public class Bow extends Weapon
{
	private int timeSinceLastShot = 0;
	private int waitTimesBetweenShots = 2000;
	
	public Bow(Entity owner, Image a, int tier)
	{
		setOwner(owner);
		setTier(tier);
		waitTimesBetweenShots = timeSinceLastShot = 2000 / tier;
		setDamage((float)(tier*4.212));
		setImage(a);
	}
	
	@Override
	public void attack() 
	{
		if(timeSinceLastShot < waitTimesBetweenShots)
			return;
		timeSinceLastShot = 0;
		
		getOwner().getWorld().addObject(new Arrow(getOwner().getX() + getOwner().getWidth() / 2,
							getOwner().getY() + getOwner().getHeight() / 2, 
							15.0f, 10.0f, 
							getOwner().getWorld(), this, Resources.getImage("arrow")));
	}
	
	@Override
	public void update(int delta)
	{
		timeSinceLastShot += delta;
	}
	
	@Override
	public Bow upgrade() 
	{
		return new Bow(getOwner(), getImage(), getTier() + 1);
	}
}

=== Sword ===
package com.corntrip.turnbased.gameobject.modifier.equips;

import java.util.ArrayList;

import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.living.LivingEntity;

public class Sword extends SwungWeapon
{
	public Sword(float x, float y, float w, float h, Entity owner, Image a, int tier)
	{
		super(x, y, w, h, 500 / tier);
		setTier(tier);
		setDamage((float) (tier*6.862));
		setOwner(owner);
		setImage(a);
	}
	
	@Override
	public void attack()
	{
		if(getTimeSinceLastSwing() < getWaitTimesBetweenSwings())
			return;
		setTimeSinceLastSwing(0);
		
		ArrayList<Entity> enemiesHit = generateHitbox(getX(), getY(), getWidth(), getHeight());
		
		for(Entity hitEnemy : enemiesHit)
		{
			if(hitEnemy instanceof LivingEntity)
			{
				((LivingEntity) hitEnemy).takeDamage((int)(getDamage()+0.5));;
			}
		}
		
		setRotation(90);
	}
	
	@Override
	public Sword upgrade() 
	{		
		return new Sword(getX(), getY(), getWidth(), getHeight(), getOwner(), getImage(), getTier() + 1);
	}
}

=== SwungWeapon ===
package com.corntrip.turnbased.gameobject.modifier.equips;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;

public abstract class SwungWeapon extends Weapon
{
	private float x, y, width, height;
	private float rotation;
	private int timeSinceLastSwing;
	private int waitTimesBetweenSwings;
	
	public SwungWeapon(float x, float y, float w, float h, int waitTime)
	{
		this.x = x;
		this.y = y;
		this.width = w;
		this.height = h;
		this.waitTimesBetweenSwings = timeSinceLastSwing = waitTime;
		rotation = 0;
	}
	
	@Override
	public void update(int delta)
	{
		if(rotation > 0)
			rotation -= 5;
		else
			rotation = 0;
		
		timeSinceLastSwing += delta;
	}
	
	@Override
	public void renderAt(GameContainer gc, Graphics gfx, float x, float y)
	{
		gfx.rotate(x + getImage().getWidth() / 2, y + getImage().getHeight(), rotation);
		
		super.renderAt(gc, gfx, x, y);
	}
	
	public float getX() { return x; }
	public float getY() { return y; }
	public float getWidth() { return width; }
	public float getHeight() { return height; }

	public void setX(float x) { this.x = x; }
	public void setY(float y) { this.y = y; }
	public void setWidth(float width) { this.width = width; }
	public void setHeight(float height) { this.height = height; }

	public float getRotation() { return rotation; }
	public void setRotation(float rotation) { this.rotation = rotation; }

	public int getTimeSinceLastSwing() { return timeSinceLastSwing; }
	public void setTimeSinceLastSwing(int t) { this.timeSinceLastSwing = t; }

	public int getWaitTimesBetweenSwings() { return waitTimesBetweenSwings; }
	public void setWaitTimesBetweenSwings(int w) { this.waitTimesBetweenSwings = w; }
}

=== Weapon ===
package com.corntrip.turnbased.gameobject.modifier.equips;

import java.util.ArrayList;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.modifier.Equipable;

public abstract class Weapon extends Equipable
{
	private Entity owner;
	private float damage;
	private Image image;
	private int tier;
	
	//Start x and y are the owner's hit box
	public ArrayList<Entity> generateHitbox(float startX, float startY, float width, float height)
	{
		ArrayList<Entity> itemsHit = new ArrayList<>();
		
		for(GameObject a: owner.getWorld().getEntities())
		{
			if(a instanceof LivingEntity)
			{
				//hahah no longer hits owner
				if((!owner.equals(a) && ((LivingEntity)a).collidingWith(startX, startY, width, height)))
				{
					itemsHit.add((Entity) a);
				}
			}
		}
		return itemsHit;
	}
	
	public void renderAt(GameContainer gc, Graphics gfx, float x, float y)
	{
		getImage().draw(x, y);
	}
	
	public abstract void attack();
	
	public abstract Weapon upgrade();
	public abstract void update(int delta);
	
	// Getters & Setters //
	
	public void setTier(int t) { tier = t; }
	public int getTier() { return tier; }
	public float getDamage() { return damage; }
	public Entity getOwner() { return owner; }
	public Image getImage() { return image; }
	public void setImage(Image image) { this.image = image; }
	public void setOwner(Entity owner) { this.owner = owner; }
	public void setDamage(float damage) { this.damage = damage; }
}

=== Arrow ===
package com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.modifier.equips.Weapon;
import com.corntrip.turnbased.world.World;

public class Arrow extends Projectile
{
	public Arrow(float startX, float startY, float w, float h, World world, Weapon wep, Image image)
	{
		super(startX, startY, w, h, world, wep, wep.getOwner().getRotation(), image);	
	}

	@Override
	public float flightSpeed() 
	{
		return 20.0f + getWeapon().getTier();
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		gfx.rotate((getX() - offsetX) + getWidth() / 2, (getY() - offsetY) + getHeight() / 2, getRotation());
		getImage().draw(getX() - offsetX, getY() - offsetY);
	}
}

=== Projectile ===
package com.corntrip.turnbased.gameobject.modifier.equips.weaponUtil;

import java.util.List;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.modifier.equips.Weapon;
import com.corntrip.turnbased.world.World;

public abstract class Projectile extends Entity
{
	//host item that uses the projectile
	private Weapon wep;
	//velocities, used to calc next x and/or y and rotation
	private float velX, velY;
	//total distance traveled
	private float distanceTrav;
	private Image image;
	
	private static final float INNACURACY = 25f; // more = less :P
	
	/**
	 * 
	 * @param startX: starting coord for Entity
	 * @param startY: same as x but y
	 * @param w: width
	 * @param h: height
	 * @param world: world the Entity is in
	 * @param wep: owner of the projecile (host)
	 * @param rotation: where the player is pointing in radians
	 */
	public Projectile(float startX, float startY, float w, float h, World world, Weapon wep, float rotation, Image image)
	{
		super(startX, startY, w, h, world);
		setRotation(rotation);
		this.image = image;
		this.wep = wep;
		distanceTrav = 0;
		
		setProjectileDirection();
	}
	
	/**
	 * how fast the projectile is going
	 * @return Better freaking be < 32
	 */
	public abstract float flightSpeed();
	
	/**
	 * sets how far the arrow will go
	 * @return sets how far the arrow will go
	 */
	public float flightMax()
	{
		return wep.getTier() * 600 * flightSpeed();
	}
	
	/**
	 * removes the projectile from the world
	 */
	public void endPath()
	{
		getWorld().removeObject(this);
	}
	
	/**
	 * uses super maths to set where the x,y will be aiming
	 */
	public void setProjectileDirection()
	{
		/*
		 * == TODO ==
		 * This calculation causes the arrow to move in a diamond-like pattern, causing innacuracies when moving towards the target.
		 * This effect is strongest at angles +-45 and +-135
		 * This effect is weakest at angles +- 0 and +- 180
		 */
		if(getRotation() >= 0 && getRotation() < 90)
		{
			velY = getRotation() / 90;
			velX = 1 - velY;
		}
		else if(getRotation() >= 90 && getRotation() <= 180)
		{
			velY = Math.abs(getRotation() / 90 - 2);
			velX = -1 + velY;
		}
		else if(getRotation() > -180 && getRotation() < -90)
		{
			velY = ((getRotation() + 180) / -90);
			velX = -1 - velY;
		}
		else
		{
			velY = getRotation() / 90;
			velX = 1 + velY;
		}
		
		velY += (Math.random() / INNACURACY - 0.5 / INNACURACY);
		velX += (Math.random() / INNACURACY - 0.5 / INNACURACY);
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		//once it reaches it's distance it's removed from the world
		//the issue with this is that the diagonals will be shorter than the verticals, I think
		if(distanceTrav >= flightMax())
		{
			endPath();
		}
		
		//setting the new x,y coordinates according to the algorithm
		setX(getX() + velX * flightSpeed());
		setY(getY() + velY * flightSpeed());
		
		//checks the enemies hit
		List<Entity> enemiesHit = wep.generateHitbox(super.getX(), super.getY(), super.getWidth(), super.getHeight());
		
		//hits the first enemy and destroys the projectile
		if(enemiesHit.size() > 0)
		{
			((LivingEntity)enemiesHit.get(0)).takeDamage((int)(wep.getDamage()+0.5));
			endPath();
		}
		
		//increases the current distance traveled
		distanceTrav += flightSpeed();
	}

	public Image getImage() { return image; }

	public void setImage(Image image) { this.image = image;}

	public Weapon getWeapon() { return wep; }
}

=== Tree ===
package com.corntrip.turnbased.gameobject.nonliving;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Resources;

public class Tree extends GameObject
{
	private Image texture;
	
	/**
	 * Sits there and acts like a wall.
	 * @param startX The x to sit at
	 * @param startY The y to sit at
	 * @param w The width of the wall
	 * @param h The height of the wall
	 */
	public Tree(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		texture = Resources.getImage("tree");
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float xOffset, float yOffset)
	{
		texture.draw(getX() - xOffset, getY() - yOffset);
	}
}

=== Wall ===
package com.corntrip.turnbased.gameobject.nonliving;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.gameobject.GameObject;

public class Wall extends GameObject
{
	private Image texture;
	
	/**
	 * Sits there and acts like a wall.
	 * @param startX The x to sit at
	 * @param startY The y to sit at
	 * @param w The width of the wall
	 * @param h The height of the wall
	 */
	public Wall(float startX, float startY, float w, float h, Image texture)
	{
		super(startX, startY, w, h);
		this.texture = texture;
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float xOffset, float yOffset)
	{
		texture.draw(getX() - xOffset, getY() - yOffset);
	}
}

=== GoldResource ===
package com.corntrip.turnbased.gameobject.nonliving.resources;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;

import com.corntrip.turnbased.util.Resources;

public class GoldResource extends Resource
{
	private Image img;
	
	public GoldResource(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		img = Resources.getImage("gold");
	}
	
	@Override
	public int getPtsValue()
	{
		return 1;
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY)
	{
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	@Override
	public Resource createNew()
	{
		return new GoldResource(getX(), getY(), getWidth(), getHeight());
	}
}

=== Resource ===
package com.corntrip.turnbased.gameobject.nonliving.resources;

import com.corntrip.turnbased.gameobject.GameObject;

public abstract class Resource extends GameObject
{
	public Resource(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
	}
	
	public abstract int getPtsValue();
	public abstract Resource createNew();
}

=== ResourceDeposit ===
package com.corntrip.turnbased.gameobject.nonliving.resources;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Resources;

public class ResourceDeposit extends GameObject
{
	private Image img;
	
	public ResourceDeposit(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		img = Resources.getImage("deposit");
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{		
		img.draw(getX() - offsetX, getY() - offsetY);
	}
}

=== ResourceGenerator ===
package com.corntrip.turnbased.gameobject.nonliving.resources;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.util.Resources;
import com.corntrip.turnbased.world.World;

public class ResourceGenerator extends Entity
{
	private int timeSinceLastSpawn = 0;
	private int spawnDelayMS;
	private Resource resource;
	private Resource resourceLaidDown = null;
	
	private Image img;
	
	public ResourceGenerator(float startX, float startY, float w, float h, World world, int spawnDelayMS, Resource resource)
	{
		super(startX, startY, w, h, world);
		this.spawnDelayMS = spawnDelayMS;
		this.resource = resource;
		
		img = Resources.getImage("generator");
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY)
	{
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	@Override
	public void update(GameContainer gc, int delta) throws SlickException
	{
		if(resourceLaidDown != null)
		{
			if(!getWorld().containsObject(resourceLaidDown))
			{
				resourceLaidDown = null;
			}
		}
		
		if(resourceLaidDown == null)
			timeSinceLastSpawn += delta; // Only spawn if no resource is present
		else
			timeSinceLastSpawn = 0;
		
		if(timeSinceLastSpawn >= spawnDelayMS)
		{
			resourceLaidDown = resource.createNew();
			timeSinceLastSpawn = 0;
			resourceLaidDown.setX((int)(getX() + (Math.random() * 200) - 50));
			resourceLaidDown.setY((int)(getY() + (Math.random() * 200) - 50));
			getWorld().addObject(resourceLaidDown);
		}
	}
}

=== Townhall ===
package com.corntrip.turnbased.gameobject.nonliving.townhall;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Resources;

public class Townhall extends GameObject
{
	private Image img;
	
	public Townhall(float startX, float startY, float w, float h)
	{
		super(startX, startY, w, h);
		
		img = Resources.getImage("townhall");
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		img.draw(getX() - offsetX, getY() - offsetY);
	}
	
	public boolean withinRange(GameObject go)
	{
		float thisAnchorX = getX() + getWidth() / 2;
		float thisAnchorY = getY() + getHeight() / 2;
		
		float theirAnchorX = go.getX() + go.getWidth() / 2;
		float theirAnchorY = go.getY() - go.getHeight() / 2;
		
		double distanceAway = Math.sqrt(Math.pow(theirAnchorX - thisAnchorX, 2) + Math.pow(theirAnchorY - thisAnchorY, 2));
		
		return distanceAway < (getWidth() + getHeight());
	}
}

=== GUI ===
package com.corntrip.turnbased.gui;

import java.util.ArrayList;
import java.util.List;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.rendering.IRenderable;

public class GUI implements IRenderable
{
	List<GUIElement> elements = new ArrayList<>();
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		for(GUIElement e : elements)
		{
			e.render(gc, gfx, offsetX, offsetY);
		}
	}
	
	public void addElement(GUIElement elem)
	{
		elements.add(elem);
	}
	
	public boolean removeElement(GUIElement elem)
	{
		return elements.remove(elem);
	}
	
	public void keypress(int key)
	{
		/*for(GUIElement e : elements)
		{
			e.handleKey(key);
		}*/
	}
}

=== GUIBar ===
package com.corntrip.turnbased.gui;

public abstract class GUIBar extends GUIElement
{
	private float width, height;
	public GUIBar(float x, float y, float w, float h)
	{
		super(x, y);
		width = w;
		height = h;
	}
	
	// Getters & Setters //
	
	public float getWidth() { return width; }
	public void setWidth(float width) { this.width = width; }
	
	public float getHeight() { return height; }
	public void setHeight(float height) { this.height = height; }
}

=== GUIElement ===
package com.corntrip.turnbased.gui;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.rendering.IRenderable;

public abstract class GUIElement implements IRenderable
{
	private float x, y;
	
	public GUIElement(float x, float y)
	{
		this.x = x;
		this.y = y;
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public abstract void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException;
	
	//public abstract void handleKey(int key); <-- TODO: Put me somewhere else

	public float getX() { return x; }
	public void setX(float x) { this.x = x; }

	public float getY() { return y; }
	public void setY(float y) { this.y = y; }
}

=== HealthBarGUI ===
package com.corntrip.turnbased.gui;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

public class HealthBarGUI extends GUIBar
{
	private Color healthBackground, healthColor;
	private int health, maxHealth;
	
	public HealthBarGUI(float x, float y, float w, float h, Color healthBackground, Color healthColor, int health, int maxHealth)
	{		
		super(x, y, w, h);
		this.healthBackground = healthBackground;
		this.healthColor = healthColor;
		this.health = health;
		this.maxHealth = maxHealth;
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		gfx.setColor(healthBackground);
		gfx.fillRect(getX() - offsetX, getY() - offsetY, getWidth(), getHeight());
		
		gfx.setColor(healthColor);
		gfx.fillRect(getX() - offsetX, getY() - offsetY, health / (float)maxHealth * getWidth(), getHeight());
	}
	
	// Getters & Setters //
	
	public Color getHealthBackground() { return healthBackground; }
	public void setHealthBackground(Color healthBackground) { this.healthBackground = healthBackground; }

	public Color getHealthColor() { return healthColor; }
	public void setHealthColor(Color healthColor) { this.healthColor = healthColor; }

	public int getHealth() { return health; }
	public void setHealth(int health) { this.health = health; }

	public int getMaxHealth() { return maxHealth; }
	public void setMaxHealth(int maxHealth) { this.maxHealth = maxHealth; }
}

=== ImageGUI ===
package com.corntrip.turnbased.gui;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

public class ImageGUI extends GUIElement
{
	private Image image;
	
	public ImageGUI(float x, float y, Image image)
	{
		super(x, y);
		this.image = image;
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		image.draw(getX() - offsetX, getY() - offsetY);
	}

	public Image getImage() { return image; }
	public void setImage(Image image) { this.image = image; }
}

=== TextGUI ===
package com.corntrip.turnbased.gui;

import java.awt.Font;

import org.newdawn.slick.Color;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.TrueTypeFont;

public class TextGUI extends GUIElement
{
	private String text;
	private Color textColor;
	private boolean centered = false;
	
	private int fontWidth = 0;
	private TrueTypeFont font = new TrueTypeFont(new Font("Verdana", Font.PLAIN, 16), true);
	
	public TextGUI(float x, float y, String text, Color textColor)
	{
		super(x, y);
		this.text = text;
		this.textColor = textColor;
		
		fontWidth = font.getWidth(text);
	}

	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		gfx.setColor(textColor);
		if(!centered)
		{
			font.drawString(getX() - offsetX, getY() - offsetY, text, textColor);
		}
		else
		{
			font.drawString(getX() - fontWidth / 2 - offsetX, getY() - offsetY, text, textColor);
		}
	}
	
	public void setCentered(boolean c) { centered = c; }
	public boolean isCentered() { return centered; }

	public String getText() { return text; }	
	public void setText(String text) { this.text = text; }

	public Color getTextColor() { return textColor; }
	public void setTextColor(Color textColor) { this.textColor = textColor; }

	public TrueTypeFont getFont() { return font; }
	public void setFont(TrueTypeFont font) { this.font = font; }
}

=== ICollidable ===
package com.corntrip.turnbased.physics;

public interface ICollidable
{
	/**
	 * Sees if this collidable object is colliding with another collidable object
	 * @param other The object to check if the collision is happening with
	 * @return true if it is colliding, false if not
	 */
	public boolean collidingWith(ICollidable other);
	
	/**
	 * Checks if the specified position and dimensions would collide with another collidable object
	 * @param other The object to check if the collision is happening with
	 * @param x The x coordinate to check
	 * @param y The y coordinate to check
	 * @param width The width of the area to check
	 * @param height The height of the area to check
	 * @return true if it is colliding, false if not
	 */
	public boolean collidingWith(float x, float y, float width, float height);
	
	// Getters & Setters //
	public float getWidth();
	public float getHeight();
	
	public float getX();
	public float getY();
}

=== Camera ===
package com.corntrip.turnbased.rendering;

import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.util.Helper;

public class Camera
{
	private float xOffset, yOffset;
	private float visibleWidth, visibleHeight;
	private float mapWidth, mapHeight;
	
	/**
	 * Creates a Camera Object used to center around a given GameObject using the screen's width & height
	 * @param x The starting x offset of the camera
	 * @param y The starting y offset of the camera
	 * @param vw The screen's width
	 * @param vh The screen's height
	 * @param mw The total area the camera can travel in's width
	 * @param mh The total area the camera can travel in's height
	 */
	public Camera(float x, float y, float vw, float vh, float mw, float mh)
	{
		xOffset = x;
		yOffset = y;
		visibleWidth = vw;
		visibleHeight = vh;
		mapHeight = mh;
		mapWidth = mw;
	}
	
	/**
	 * Puts the object to center around in the center of the camera's viewpoint, but by slowly gliding/slipping there
	 * @param go The GameObject to center around
	 */
	public void slippyCenter(GameObject go)
	{
		float slippyFactor = 0.1f;
		
		xOffset += slippyFactor * (go.getX() - visibleWidth / 2 + go.getWidth() / 2 - xOffset);
		yOffset += slippyFactor * (go.getY() - visibleHeight / 2 + go.getHeight() / 2 - yOffset);
		
		xOffset = Helper.clamp(xOffset, 0, mapWidth - visibleWidth);
		yOffset = Helper.clamp(yOffset, 0, mapHeight - visibleHeight);
	}
	
	/**
	 * Puts the object to center around in the center of the camera's viewpoint
	 * @param go The GameObject to center around
	 */
	public void center(GameObject go)
	{
		xOffset = go.getX() - visibleWidth / 2 + go.getWidth() / 2;
		yOffset = go.getY() - visibleHeight / 2 + go.getHeight() / 2;
		
		xOffset = Helper.clamp(xOffset, 0, mapWidth - visibleWidth);
		yOffset = Helper.clamp(yOffset, 0, mapHeight - visibleHeight);
	}
	
	// Getters & Setters //
	
	public float getXOffset() { return xOffset; }
	public void setXOffset(float xOffset) { this.xOffset = xOffset; }

	public float getYOffset() { return yOffset; }
	public void setYOffset(float yOffset) { this.yOffset = yOffset; }

	public float getScreenWidth() { return visibleWidth; }
	public void setScreenWidth(float screenWidth) { this.visibleWidth = screenWidth; }
	
	public float getScreenHeight() { return visibleHeight; }
	public void setScreenHeight(float screenHeight) { this.visibleHeight = screenHeight; }
}

=== IRenderable ===
package com.corntrip.turnbased.rendering;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

public interface IRenderable
{
	/**
	 * Draws the object at a position on the window
	 * @param gc The main game's container
	 * @param gfx The Graphics object to use to draw
	 * @throws SlickException Potentially thrown when drawing
	 */
	public void render(GameContainer gc, Graphics gfx) throws SlickException;
	
	/**
	 * Draws the object at a specified position on the window
	 * @param gc The main game's container
	 * @param gfx The Graphics object to use to draw
	 * @param offsetX The offset on the x axis to use when drawing the object
	 * @param offsetY The offset on the y axis to use when drawing the object
	 * @throws SlickException Potentially thrown when drawing
	 */
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException;
}

=== Helper ===
package com.corntrip.turnbased.util;

public class Helper
{
	/**
	 * Clamps a value between a minimum and a maximum
	 * @param val The value to clamp between the minimum and maximum
	 * @param min The minimum value to constrain the value between
	 * @param max The maximum value to constrain the value between
	 * @return if the value is less than the minimum, the minimum value passed; if it is greator than the max, then the max is returned.  Otherwise the value passed in is returned.
	 */
	public static float clamp(float val, float min, float max)
	{
		if(val < min)
			return min;
		if(val > max)
			return max;
		return val;
	}
	
	/**
	 * Finds the angle in degrees from point A to point B
	 * @param fromX Point A's x coordinate
	 * @param fromY Point A's y coordinate
	 * @param toX Point B's x coordinate
	 * @param toY Point B's y coordinate
	 * @return The angle in degrees from point A to point B
	 */
	public static float getAngle(float fromX, float fromY, float toX, float toY)
	{
		return (float)Math.toDegrees(Math.atan2(toY - fromY, toX - fromX));
	}
	
	public static float getXCoordFromRotation(float rotation, float anchorX, float anchorY, float oldX)
	{
		// Convert to radians because java likes them
		double radians = Math.toRadians(rotation);
		
		// Do fancy maths **not** stolen from stack overflow
		return (float)(Math.cos(radians) * (oldX - anchorX) - Math.sin(radians) * (oldX - anchorY) + anchorX);
	}
	
	public static float getYCoordFromRotation(float rotation, float anchorX, float anchorY, float oldX, float oldY)
	{
		// Convert to radians because java likes them
		double radians = Math.toRadians(rotation);
		
		// Do fancy maths **not** stolen from stack overflow
		return (float)(Math.sin(radians) * (oldX - anchorX) + Math.cos(radians) * (oldY - anchorY) + anchorY);
	}
}

=== Reference ===
package com.corntrip.turnbased.util;

import java.awt.Color;

public class Reference
{
	/**
	 * Indicates whether or not the game is currently being debugged
	 */
	public static final boolean DEBUG = false;
	
	/**
	 * The maximum FPS the window should reach
	 */
	public static final int MAX_FPS = 60;
	
	/**
	 * Each tile in the world is 32x32
	 */
	public static final int TILE_DIMENSIONS = 32;
	
	/**
	 * The dimensions of the window
	 */
	public static final int WINDOW_WIDTH = 720, WINDOW_HEIGHT = (int)(WINDOW_WIDTH * 12.0/16);
	
	/**
	 * If a float is +- off a number by this amount they're basically equal
	 */
	public static final float ALMOST_EQUAL = 0.004f;
	
	public static final Color RESOURCE_SPAWN_POINT_KEY = new Color(255, 0, 0);
	public static final Color TREE_SPAWN_KEY           = new Color(0, 255, 0);
	public static final Color WALL_SPAWN_KEY           = new Color(0, 0, 255);
	public static final Color TOWN_HALL_KEY            = new Color(255, 0, 255);
	public static final Color DEPOSIT_KEY              = new Color(0, 0, 0);
	public static final Color PLAYER_KEY               = new Color(255, 255, 0);
	
	public static final Color TEST_ENEMY               = new Color(255, 0, 128);
}

=== Resources ===
package com.corntrip.turnbased.util;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.imageio.ImageIO;

import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.Sound;
import org.newdawn.slick.SpriteSheet;
import org.newdawn.slick.opengl.Texture;
import org.newdawn.slick.util.BufferedImageUtil;

/**
 * Handles all the resources of the game
 */
public class Resources
{
	/**
	 * Stores Images in accordance with their keys
	 */
	private static Map<String, Image> images = new HashMap<>();
	
	/**
	 * Stores SpriteSheets in accordance with their keys
	 */
	private static Map<String, SpriteSheet> spriteSheets = new HashMap<>();
	
	/**
	 * Stores Sounds in accordance with their keys
	 */
	private static Map<String, Sound> sounds = new HashMap<>();
	
	/**
	 * Loads a SpriteSheet found at a given file path starting in res/images/spritesheets/
	 * @param path The path to the file in the res/images/spritesheets/ directory
	 * @return The SpriteSheet found, or null if the file was not found or unable to be parsed
	 */
	public static SpriteSheet loadSpriteSheet(String path, int tileWidth, int tileHeight)
	{
		path = "spritesheets/" + path;
		return new SpriteSheet(loadImage(path), tileWidth, tileHeight);
	}
	
	/**
	 * Loads an Image found at a given file path starting in res/images/
	 * @param path The path to the file in the res/images/ directory
	 * @return The Image found, or null if the file was not found or unable to be parsed
	 */
	public static Image loadImage(String path)
	{
		path = "res/images/" + path;
		Image i = null;
		try
		{			
			// The PNG loader breaks whenever I try and load a png, so I had to do this :(
			BufferedImage bufferedImage = ImageIO.read(new File(path));
		    Texture texture = BufferedImageUtil.getTexture("", bufferedImage);
		    i = new Image(texture.getImageWidth(), texture.getImageHeight());
		    i.setTexture(texture);
		    i.setFilter(Image.FILTER_NEAREST);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
			Logger.getLogger("error").log(Level.SEVERE, "Image [" + path + "] failed to load.", ex);
		}
		return i;
	}
	
	/**
	 * Loads a Sound found at a given file path starting in res/sounds/
	 * @param path The path to the file in the res/sounds/ directory
	 * @return The Sound found, or null if the file was not found or unable to be parsed
	 */
	public static Sound loadSound(String path)
	{
		Sound s = null;
		try
		{
			s = new Sound("res/sounds/" + path);
		}
		catch(SlickException ex)
		{
			Logger.getLogger("error").log(Level.SEVERE, "Sound [" + path + "] failed to load.", ex);
		}
		return s;
	}
	
	/**
	 * Registers a sound that can be found by a given sound name.
	 * @param soundName The String key to recieve the sound by. <b>Note: If a sound with this name already exists it will be overwritten</b>
	 * @param sound The Sound to store
	 */
	public static void registerSound(String soundName, Sound sound)
	{
		sounds.put(soundName, sound);
	}
	
	/**
	 * Registers an image that can be found by a given image name.
	 * @param imageName The String key to recieve the image by. <b>Note: If an image with this name already exists it will be overwritten</b>
	 * @param img The Image to store
	 */
	public static void registerImage(String imageName, Image img)
	{
		images.put(imageName, img);
	}
	
	/**
	 * Registers a spritesheet that can be found by a given sound name.
	 * @param soundName The String key to recieve the spritesheet by. <b>Note: If a spritesheet with this name already exists it will be overwritten</b>
	 * @param sound The SpriteSheet to store
	 */
	public static void registerSpriteSheet(String spriteSheetName, SpriteSheet sheet)
	{
		spriteSheets.put(spriteSheetName, sheet);
	}
	
	/**
	 * Returns the Sound found at the given String key
	 * @param name The key the Sound is stored at
	 * @return The Sound found at the given String key if found, null if not present.
	 */
	public static Sound getSound(String name)
	{
		return sounds.get(name);
	}
	
	/**
	 * Returns the SpriteSheet found at the given String key
	 * @param name The key the SpriteSheet is stored at
	 * @return The SpriteSheet found at the given String key if found, null if not present.
	 */
	public static SpriteSheet getSpriteSheet(String name)
	{
		return spriteSheets.get(name);
	}
	
	/**
	 * Returns the Image found at the given String key
	 * @param name The key the Image is stored at
	 * @return The Image found at the given String key if found, null if not present.
	 */
	public static Image getSpriteImage(String name, int x, int y)
	{
		return spriteSheets.get(name).getSubImage(x, y);
	}
	
	/**
	 * Returns the Image found at the given String key
	 * @param name The key the Image is stored at
	 * @return The Image found at the given String key if found, null if not present.
	 */
	public static Image getImage(String name)
	{
		return images.get(name);
	}
}

=== Tile ===
package com.corntrip.turnbased.world;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.rendering.IRenderable;

public class Tile implements IRenderable
{
	private float x, y;
	private float width, height;
	
	private Image texture;

	/**
	 * A simple thing to render
	 * @param x The x position to draw at
	 * @param y The y position to draw at
	 * @param w The width of the tile to draw
	 * @param h The height of the tile to draw
	 */
	public Tile(float x, float y, float w, float h, Image texture)
	{
		this.x = x;
		this.y = y;
		this.width = w;
		this.height = h;
		this.texture = texture;
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx, float offsetX, float offsetY) throws SlickException
	{
		texture.draw(x - offsetX, y - offsetY);
	}

	public float getX() { return x; }
	public void setX(float x) { this.x = x; }

	public float getY() { return y; }
	public void setY(float y) { this.y = y; }

	public float getWidth() { return width; }
	public void setWidth(float width) { this.width = width; }

	public float getHeight() { return height; }
	public void setHeight(float height) { this.height = height; }
}

=== World ===
package com.corntrip.turnbased.world;

import java.util.ArrayList;
import java.util.List;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;

import com.corntrip.turnbased.gameobject.Entity;
import com.corntrip.turnbased.gameobject.GameObject;
import com.corntrip.turnbased.gameobject.living.Enemy;
import com.corntrip.turnbased.gameobject.living.LivingEntity;
import com.corntrip.turnbased.gameobject.living.TestEnemy;
import com.corntrip.turnbased.gameobject.nonliving.townhall.Townhall;
import com.corntrip.turnbased.rendering.Camera;
import com.corntrip.turnbased.rendering.IRenderable;
import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;

public class World implements IRenderable
{	
	/**
	 * Keeps track of the Entity to be treated as the player
	 */
	private LivingEntity player = null;
	
	/**
	 * Keeps track of the GameObject to be treated as the town hall
	 */
	private Townhall townhall = null;
	
	/**
	 * Every GameObject in the scene (including Entities) is stored in here
	 */
	private List<GameObject> gameObjects = new ArrayList<>();
	
	/**
	 * Every Entity in the scene is stored here (each entity will also have a copy in the gameObjects List)
	 */
	private List<Entity> entities = new ArrayList<>();
	
	/**
	 * The Camera used when rendering the world; if no player is defined it simply remains in its default position
	 */
	private Camera cam;
	
	/**
	 * Time in ms since the last spawn
	 */
	private int timeSinceLastSpawn = 0;
	
	/**
	 * Keeps track of which wave of enemies it is on
	 */
	private int wave = 1;
	
	/**
	 * The dimensions of the world
	 */
	private final int WIDTH, HEIGHT;
	
	/**
	 * Every tile in the world
	 */
	private Tile[][] tiles;
	
	/**
	 * Keeps track of objects to be removed after being messed with
	 */
	private List<GameObject> objectsToBeRemoved = new ArrayList<>();
	
	/**
	 * A world holds every object in a scene and handles rendering and updating them all
	 * @param width The total width of the world
	 * @param height The total height of the world
	 */
	public World(int width, int height)
	{
		WIDTH = width;
		HEIGHT = height;
		
		int tilesAmtY = HEIGHT / Reference.TILE_DIMENSIONS;
		int tilesAmtX = WIDTH  / Reference.TILE_DIMENSIONS;
		
		tiles = new Tile[tilesAmtY][tilesAmtX];
		
		// Fills the tiles array with new tiles (TODO: Replace with an image-loaded scene)
		for(int ty = 0; ty < tilesAmtY; ty++)
		{
			for(int tx = 0; tx < tilesAmtX; tx++)
			{
				tiles[ty][tx] = new Tile(tx * Reference.TILE_DIMENSIONS, ty * Reference.TILE_DIMENSIONS, 
											Reference.TILE_DIMENSIONS, Reference.TILE_DIMENSIONS, 
											Resources.getSpriteImage("tiles", (int)(Math.random() + 0.5), (int)(Math.random() + 0.5)));
			}
		}
		
		if(Reference.DEBUG)
			System.out.println("Total Tiles: " + tiles.length * tiles[0].length);
		
		cam = new Camera(0, 0, Reference.WINDOW_WIDTH, Reference.WINDOW_HEIGHT, WIDTH, HEIGHT);
	}
	
	/**
	 * Renders each object in the world with a specified offset added to the camera's offset
	 */
	@Override
	public void render(GameContainer gc, Graphics gfx, float passedXOff, float passedYOff) throws SlickException
	{
		float camXOff = cam.getXOffset();
		float camYOff = cam.getYOffset();
		
		for(int y = (int) (camYOff / Reference.TILE_DIMENSIONS); y < (camYOff + cam.getScreenHeight()) / Reference.TILE_DIMENSIONS && y < HEIGHT / Reference.TILE_DIMENSIONS; y++)
		{
			for(int x = (int) (camXOff / Reference.TILE_DIMENSIONS); x < (camXOff + cam.getScreenWidth()) / Reference.TILE_DIMENSIONS && x < WIDTH / Reference.TILE_DIMENSIONS; x++)
			{
				tiles[y][x].render(gc, gfx, camXOff, camYOff);
			}
		}
		
		for(GameObject o : gameObjects)
		{
			if(!o.equals(getPlayer()))
			{
				if(o.getX() + o.getWidth() > cam.getXOffset() && o.getX() < cam.getXOffset() + cam.getScreenWidth())
				{
					if(o.getY() + o.getHeight() > cam.getYOffset() && o.getY() < cam.getYOffset() + cam.getScreenHeight())
					{
						gfx.pushTransform(); // Makes sure this drawing doesn't mess w/ any others
						o.render(gc, gfx, camXOff + passedXOff, camYOff + passedYOff);
						gfx.popTransform();
					}
				}
			}
		}
		
		if(getPlayer() != null) // Render the player last so it's not behind walls n stuff
			getPlayer().render(gc, gfx, camXOff + passedXOff, camYOff + passedYOff);
	}
	
	@Override
	public void render(GameContainer gc, Graphics gfx) throws SlickException
	{
		render(gc, gfx, 0, 0);
	}
	
	public void update(GameContainer gc, int delta) throws SlickException
	{
		for(int i = 0;  i < entities.size(); i++)
		{
			Entity e = entities.get(i);
			e.update(gc, delta);
		}
		
		if(player != null)
			cam.slippyCenter(player);
		
		timeSinceLastSpawn += delta;
		if(timeSinceLastSpawn > 1000)
		{
			//spawnEnemies();
			timeSinceLastSpawn = 0;
			wave++;
		}
		
		while(objectsToBeRemoved.size() > 0)
		{
			GameObject go = objectsToBeRemoved.remove(0);
			removeObjectUnsafely(go);
		}
	}
	
	public void spawnEnemies()
	{
		int enemyW = 32;
		int enemyH = 32;
		
		int numOfEnemies = (int)Math.pow(6, wave * 0.1);

		for(int i = 0; i < numOfEnemies; i++)
		{
			float x, y;
			
			// Loop for searching for a good position
			searchLoop:
			do
			{
				x = (float) (Math.random() * WIDTH);
				y = (float) (Math.random() * HEIGHT);
				
				// Make sure it's not colliding with any objects in the scene
				for(GameObject go : gameObjects)
				{
					if(go.collidingWith(x, y, enemyW, enemyH))
					{
						continue searchLoop;
					}
				}
			} while(x + enemyW >= cam.getXOffset() && x <= cam.getXOffset() + cam.getScreenWidth() 
				 && y + enemyH >= cam.getYOffset() && y <= cam.getYOffset() + cam.getScreenHeight()); // Makes sure it won't spawn in the player's viewpoint
			
			Enemy e = new TestEnemy(x, y, enemyW, enemyH, this, getPlayer());
			addObject(e);
		}
	}
	
	/**
	 * Tells the world who to center the camera on and other things that are player-specific. This also adds the player to the object list.
	 * @param ent The Entity to treat as the player
	 */
	public void setPlayer(LivingEntity ent)
	{
		player = ent;
		cam.center(player);
		addObject(player);
	}
	
	/**
	 * Assigns the town hall in the world to be the given object, and adds it to the world's registered objects.
	 * @param th The Townhall to be added
	 */
	public void setTownhall(Townhall th)
	{
		addObject(th);
		townhall = th;
	}
	
	/**
	 * Adds an object to be handled by the world
	 * @param obj The object to add to the world
	 */
	public void addObject(GameObject obj)
	{
		if(obj instanceof Entity)
			entities.add((Entity)obj);
		
		gameObjects.add(obj);
	}
	
	/**
	 * Removes an object from the world after the world is done updating
	 * @param obj The object to remove
	 */
	public void removeObject(GameObject obj)
	{
		objectsToBeRemoved.add(obj);
	}
	
	/**
	 * Removes an object from the world regardless of if things are updating or not
	 * @param obj The object to remove
	 */
	private void removeObjectUnsafely(GameObject obj)
	{
		gameObjects.remove(obj);
		if(obj instanceof Entity)
			entities.remove(obj);
	}
	
	public boolean containsObject(GameObject obj)
	{
		for(GameObject o : gameObjects)
			if(o.equals(obj))
				return true;
		return false;
	}
	
	public List<GameObject> getGameObjects() { return gameObjects; }
	public List<Entity> getEntities() { return entities; }
	
	public LivingEntity getPlayer() { return player; }
	
	public Townhall getTownhall() { return townhall; }

	public float getWidth() { return WIDTH; }
	public float getHeight() { return HEIGHT; }
}

=== WorldLoader ===
package com.corntrip.turnbased.world;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

import com.corntrip.turnbased.gameobject.living.Enemy;
import com.corntrip.turnbased.gameobject.living.Player;
import com.corntrip.turnbased.gameobject.living.TestEnemy;
import com.corntrip.turnbased.gameobject.nonliving.Tree;
import com.corntrip.turnbased.gameobject.nonliving.Wall;
import com.corntrip.turnbased.gameobject.nonliving.resources.GoldResource;
import com.corntrip.turnbased.gameobject.nonliving.resources.ResourceDeposit;
import com.corntrip.turnbased.gameobject.nonliving.resources.ResourceGenerator;
import com.corntrip.turnbased.gameobject.nonliving.townhall.Townhall;
import com.corntrip.turnbased.util.Reference;
import com.corntrip.turnbased.util.Resources;

public class WorldLoader
{
	public static World generateWorldFromImage(BufferedImage img)
	{
		World world = new World(img.getWidth() * Reference.TILE_DIMENSIONS, img.getHeight() * Reference.TILE_DIMENSIONS);
		
		final int w = Reference.TILE_DIMENSIONS, h = Reference.TILE_DIMENSIONS;
		
		List<Enemy> enemies = new ArrayList<>();
		
		for(int y = 0; y < img.getHeight(); y++)
		{
			for(int x = 0; x < img.getWidth(); x++)
			{
				Color c = new Color(img.getRGB(x, y));
				
				final float actualX = x * w;
				final float actualY = y * h;
				
				if(c.equals(Reference.RESOURCE_SPAWN_POINT_KEY))
				{
					world.addObject(new ResourceGenerator(actualX, actualY, w * 2, h * 2, world, 10000, 
							new GoldResource(actualX + w / 2, actualY + h / 2, w, h)));
				}
				else if(c.equals(Reference.TREE_SPAWN_KEY))
				{
					world.addObject(new Tree(actualX, actualY, w * 2, h * 3));
				}
				else if(c.equals(Reference.WALL_SPAWN_KEY))
				{
					world.addObject(new Wall(actualX, actualY, w, h, 
										Resources.getImage("wall")));
				}
				else if(c.equals(Reference.TOWN_HALL_KEY))
				{
					world.setTownhall(new Townhall(actualX, actualY, w * 4, h * 4));
				}
				else if(c.equals(Reference.PLAYER_KEY))
				{
					world.setPlayer(new Player(actualX, actualY, w, h, world));
				}
				else if(c.equals(Reference.DEPOSIT_KEY))
				{
					world.addObject(new ResourceDeposit(actualX, actualY, w, h));
				}
				else if(c.equals(Reference.TEST_ENEMY))
				{
					Enemy e = new TestEnemy(actualY, actualY, w, h, world, null);
					world.addObject(e);
					enemies.add(e);
				}
			}
		}
		
		for(Enemy e : enemies)
		{
			e.setTarget(world.getPlayer());
		}
		
		return world;
	}
}
